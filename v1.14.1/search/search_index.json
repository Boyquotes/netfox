{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"netfox A set of addons for responsive online games with the Godot engine . Features \u23f2\ufe0f Consistent timing across multiple machines \ud83d\udda5\ufe0f Supports client-server architecture \ud83e\uddc8 Smooth motion with easy-to-use interpolation \ud83d\udca8 Lag compensation with Client-side Prediction and Server-side Reconciliation \ud83d\udedc Bullet-proof connectivity with noray integration Overview The package consists of multiple addons, each with different features: netfox The core package, implements timing, rollback and other multiplayer features Start here netfox.noray Implements noray integration to establish connection between players Useful for online games netfox.extras Provides high-level, game-specific, convenience features built on top of netfox, like base classes for input management or weapons Check for reusable components for your game netfox.internals Shared utilities for the other addons Included as dependency, no need to install separately Install Releases Find the latest netfox under Releases Each release contains the addons, and a build of Forest Brawl for Windows and Linux. Each addon has its dependencies packed with it - e.g. \"netfox.extras.vx.y.z.zip\" also contains both netfox and netfox.internals . Note: For releases before v1.1.1, a separate \".with-deps.zip\" version contains the addon and its dependencies, while the regular zips contain only the addon itself. Asset Library Search for the addon name in Godot's AssetLib or download from the site: netfox netfox.noray netfox.extras Source Download the source and copy the addons of your choice to your Godot project. Enable the addons After adding netfox to your project, make sure to enable the addons in your project settings. Otherwise, Godot will present you with errors about undeclared identifiers. Supported versions Godot 4.x is supported by netfox. If you find any issue using any supported version, please open an issue . Forest Brawl and the other examples are written against Godot 4.1. They may or may not work when opened with any other version. Prototyping To try your game online with noray , a free to use instance is hosted at tomfol.io:8890 , the same instance used by Forest Brawl . You can use this noray instance to quickly test your games online, but is not recommended for shipping games. The instance has configured limits, and no uptime guarantees are made. About this documentation These pages assume that you are familiar with both Godot, its multiplayer capabilities, and building multiplayer games in general. Missing any of these might make your reading experience more difficult than preferred. Some links to get you up to speed: Godot Engine docs Godot Engine High-level multiplayer Networking for Physics Programmers About the tutorials The tutorials are intended to get you started fast, but don't explain much of how things work. For that, refer to the guides.","title":"Home"},{"location":"#netfox","text":"A set of addons for responsive online games with the Godot engine .","title":"netfox"},{"location":"#features","text":"\u23f2\ufe0f Consistent timing across multiple machines \ud83d\udda5\ufe0f Supports client-server architecture \ud83e\uddc8 Smooth motion with easy-to-use interpolation \ud83d\udca8 Lag compensation with Client-side Prediction and Server-side Reconciliation \ud83d\udedc Bullet-proof connectivity with noray integration","title":"Features"},{"location":"#overview","text":"The package consists of multiple addons, each with different features: netfox The core package, implements timing, rollback and other multiplayer features Start here netfox.noray Implements noray integration to establish connection between players Useful for online games netfox.extras Provides high-level, game-specific, convenience features built on top of netfox, like base classes for input management or weapons Check for reusable components for your game netfox.internals Shared utilities for the other addons Included as dependency, no need to install separately","title":"Overview"},{"location":"#install","text":"","title":"Install"},{"location":"#releases","text":"Find the latest netfox under Releases Each release contains the addons, and a build of Forest Brawl for Windows and Linux. Each addon has its dependencies packed with it - e.g. \"netfox.extras.vx.y.z.zip\" also contains both netfox and netfox.internals . Note: For releases before v1.1.1, a separate \".with-deps.zip\" version contains the addon and its dependencies, while the regular zips contain only the addon itself.","title":"Releases"},{"location":"#asset-library","text":"Search for the addon name in Godot's AssetLib or download from the site: netfox netfox.noray netfox.extras","title":"Asset Library"},{"location":"#source","text":"Download the source and copy the addons of your choice to your Godot project.","title":"Source"},{"location":"#enable-the-addons","text":"After adding netfox to your project, make sure to enable the addons in your project settings. Otherwise, Godot will present you with errors about undeclared identifiers.","title":"Enable the addons"},{"location":"#supported-versions","text":"Godot 4.x is supported by netfox. If you find any issue using any supported version, please open an issue . Forest Brawl and the other examples are written against Godot 4.1. They may or may not work when opened with any other version.","title":"Supported versions"},{"location":"#prototyping","text":"To try your game online with noray , a free to use instance is hosted at tomfol.io:8890 , the same instance used by Forest Brawl . You can use this noray instance to quickly test your games online, but is not recommended for shipping games. The instance has configured limits, and no uptime guarantees are made.","title":"Prototyping"},{"location":"#about-this-documentation","text":"These pages assume that you are familiar with both Godot, its multiplayer capabilities, and building multiplayer games in general. Missing any of these might make your reading experience more difficult than preferred. Some links to get you up to speed: Godot Engine docs Godot Engine High-level multiplayer Networking for Physics Programmers","title":"About this documentation"},{"location":"#about-the-tutorials","text":"The tutorials are intended to get you started fast, but don't explain much of how things work. For that, refer to the guides.","title":"About the tutorials"},{"location":"upgrading/","text":"Upgrading netfox Improvements are fixes are added to netfox with time, based on user feedback, resulting in newer versions. This page is inteded to help you with upgrading your game to a newer netfox version. General advice Have a backup Make sure to have a backup of your project before upgrading. While most often an addon update should be harmless, it is a good practice to backup your project regularly, and specifically before risky changes. Disable the addon(s) Before upgrading, disable the netfox addon(s) in your project, in Project Settings. After the upgrade, enable the addon(s) again. This helps with cases where an autoload or a project setting is changed. Version-specific steps This section has version-specific entries where extra actions might be necessary. Versions where the general advice holds are left out. Make sure to apply all the steps between the versions, e.g. if you're updating from 1.0.0 to 1.3.0, refer to the sections between the two versions, in this case v1.1.1. If there are no sections here for your version range, that means that the upgrade should need no extra action, aside from replacing the old netfox addon(s) with the new one(s). v1.1.1 Remove Interpolators from the project autoloads, it's a static class now.","title":"Upgrading netfox"},{"location":"upgrading/#upgrading-netfox","text":"Improvements are fixes are added to netfox with time, based on user feedback, resulting in newer versions. This page is inteded to help you with upgrading your game to a newer netfox version.","title":"Upgrading netfox"},{"location":"upgrading/#general-advice","text":"","title":"General advice"},{"location":"upgrading/#have-a-backup","text":"Make sure to have a backup of your project before upgrading. While most often an addon update should be harmless, it is a good practice to backup your project regularly, and specifically before risky changes.","title":"Have a backup"},{"location":"upgrading/#disable-the-addons","text":"Before upgrading, disable the netfox addon(s) in your project, in Project Settings. After the upgrade, enable the addon(s) again. This helps with cases where an autoload or a project setting is changed.","title":"Disable the addon(s)"},{"location":"upgrading/#version-specific-steps","text":"This section has version-specific entries where extra actions might be necessary. Versions where the general advice holds are left out. Make sure to apply all the steps between the versions, e.g. if you're updating from 1.0.0 to 1.3.0, refer to the sections between the two versions, in this case v1.1.1. If there are no sections here for your version range, that means that the upgrade should need no extra action, aside from replacing the old netfox addon(s) with the new one(s).","title":"Version-specific steps"},{"location":"upgrading/#v111","text":"Remove Interpolators from the project autoloads, it's a static class now.","title":"v1.1.1"},{"location":"netfox/concepts/authoritative-servers/","text":"Authoritative servers The idea behind multiplayer servers is replicating state. As long each player sees approximately the same things happening on their screen, the illusion of a shared world works. Naive replication To implement state replication, we could say that each player is responsible for their own state. Players see the effects of their input instantly, as they own their state and thus their avatar. The issue is that clients can't be trusted. Your game client is distributed to players, who run it in various environments. These environments are out of the developer's control, and provide an attack surface for cheats. For example, a modified game client might always report full HP no matter how many hits the player takes. If each player is responsible for their own state, the cheating player's full-HP state will be replicated to everyone else. Server as the source of truth What can be controlled is the server, with dedicated hosting. Thus, the server can be the single source of truth - or in other words, authoritative. Clients send their inputs to the server, and the server responds with the updated game state. This makes cheating difficult, as players have limited influence over the game world. Game code can also be simplified - everything that affects the gameplay is run on the server, while other things such as visual effects are run on the clients. The tradeoff is that it takes time for the updated game state to arrive from the server. This necessitates techniques that mask this delay, such as Client-side prediction and Server reconciliation . Other approaches Server-authoritative gameplay with CSP is not a silver bullet unfortunately, and different games may require different approaches to network state replication. One good example is RTS games. These games can have 50+ or even hundreds of units navigating the map and interacting. Broadcasting all of their state to all of the players from the server may not always be feasible. Instead, players broadcast their actions ( inputs ) to each other and update their game state in lockstep. While this approach can scale up to hundreds of units, it has other drawbacks. One of these is developing the game in such a way that the simulation is exactly the same across multiple CPU architectures down to each bit. For more on this approach, see: 1500 Archers on a 28.8: Network Programming in Age of Empires and Beyond For more approaches, see: Networking for Physics Programmers","title":"Authoritative servers"},{"location":"netfox/concepts/authoritative-servers/#authoritative-servers","text":"The idea behind multiplayer servers is replicating state. As long each player sees approximately the same things happening on their screen, the illusion of a shared world works.","title":"Authoritative servers"},{"location":"netfox/concepts/authoritative-servers/#naive-replication","text":"To implement state replication, we could say that each player is responsible for their own state. Players see the effects of their input instantly, as they own their state and thus their avatar. The issue is that clients can't be trusted. Your game client is distributed to players, who run it in various environments. These environments are out of the developer's control, and provide an attack surface for cheats. For example, a modified game client might always report full HP no matter how many hits the player takes. If each player is responsible for their own state, the cheating player's full-HP state will be replicated to everyone else.","title":"Naive replication"},{"location":"netfox/concepts/authoritative-servers/#server-as-the-source-of-truth","text":"What can be controlled is the server, with dedicated hosting. Thus, the server can be the single source of truth - or in other words, authoritative. Clients send their inputs to the server, and the server responds with the updated game state. This makes cheating difficult, as players have limited influence over the game world. Game code can also be simplified - everything that affects the gameplay is run on the server, while other things such as visual effects are run on the clients. The tradeoff is that it takes time for the updated game state to arrive from the server. This necessitates techniques that mask this delay, such as Client-side prediction and Server reconciliation .","title":"Server as the source of truth"},{"location":"netfox/concepts/authoritative-servers/#other-approaches","text":"Server-authoritative gameplay with CSP is not a silver bullet unfortunately, and different games may require different approaches to network state replication. One good example is RTS games. These games can have 50+ or even hundreds of units navigating the map and interacting. Broadcasting all of their state to all of the players from the server may not always be feasible. Instead, players broadcast their actions ( inputs ) to each other and update their game state in lockstep. While this approach can scale up to hundreds of units, it has other drawbacks. One of these is developing the game in such a way that the simulation is exactly the same across multiple CPU architectures down to each bit. For more on this approach, see: 1500 Archers on a 28.8: Network Programming in Age of Empires and Beyond For more approaches, see: Networking for Physics Programmers","title":"Other approaches"},{"location":"netfox/concepts/servers-clients-ownership/","text":"Servers, clients, and ownership Much of this documentation discusses things in context of servers and clients. This page is intended to clear up how this translates to Godot's concept of multiplayer ownership. Ownership in Godot In Godot's multiplayer system, each node belongs to a multiplayer peer, i.e. a player. This can be set from scripts, and is not replicated. This means that the logic assigning ownership to nodes must produce the same result on every machine for things to work consistently. Ownership in netfox To mesh better with Godot's existing conventions, netfox doesn't work in terms of server and client, but uses ownership instead. Whenever the server is mentioned, it refers to a given node's owner. In practice, this means that nodes representing game state are and should be owned by the server. Limitations At the time of writing, ownership is hard-coded in some cases. One such case is NetworkTime , which is always owned by the host peer and always takes the host peer's time as reference. This means that peer-to-peer games are not officially supported by netfox , but might be able to work with some workarounds. If feasible, you can build self-hosted games by including netfox.noray . In theory, multiple players can own different parts of the game state, but netfox is not tested for such use cases.","title":"Servers, clients, and ownership"},{"location":"netfox/concepts/servers-clients-ownership/#servers-clients-and-ownership","text":"Much of this documentation discusses things in context of servers and clients. This page is intended to clear up how this translates to Godot's concept of multiplayer ownership.","title":"Servers, clients, and ownership"},{"location":"netfox/concepts/servers-clients-ownership/#ownership-in-godot","text":"In Godot's multiplayer system, each node belongs to a multiplayer peer, i.e. a player. This can be set from scripts, and is not replicated. This means that the logic assigning ownership to nodes must produce the same result on every machine for things to work consistently.","title":"Ownership in Godot"},{"location":"netfox/concepts/servers-clients-ownership/#ownership-in-netfox","text":"To mesh better with Godot's existing conventions, netfox doesn't work in terms of server and client, but uses ownership instead. Whenever the server is mentioned, it refers to a given node's owner. In practice, this means that nodes representing game state are and should be owned by the server.","title":"Ownership in netfox"},{"location":"netfox/concepts/servers-clients-ownership/#limitations","text":"At the time of writing, ownership is hard-coded in some cases. One such case is NetworkTime , which is always owned by the host peer and always takes the host peer's time as reference. This means that peer-to-peer games are not officially supported by netfox , but might be able to work with some workarounds. If feasible, you can build self-hosted games by including netfox.noray . In theory, multiple players can own different parts of the game state, but netfox is not tested for such use cases.","title":"Limitations"},{"location":"netfox/guides/interpolators/","text":"Interpolators Tracks interpolators for various data types. Provided as an autoload. To smooth out motion between network ticks, TickInterpolator interpolates nodes' state properties between the current and the previous tick. The type of data to be interpolated is not known in advance, and can be any built-in or even custom type configured by the developer. Interpolators provides methods to register interpolators for any data type, and even provides some for built-in data types. Interpolating values Interpolators can be used to interpolate between any two values, as long as they hold the same data type: extends Node3D @export var target_node @export var approach_time = 0.5 func _process(delta): # Approach target node, if it exists if target_node: var from_xform = global_transform var to_xform = target_node.global_transform var factor = delta / approach_time global_transform = Interpolators.interpolate(from_xform, to_xform, factor) Note that in this case, Interpolators will try to look up the appropriate interpolator based on the provided values. If no interpolator is found, a fallback is used, that simply returns the value closer to factor - i.e. the starting value if factor is less than 0.5 and the target value otherwise. Caching interpolators To avoid having to look up the right interpolator every frame, you can cache it: extends Node3D @export target_node @export approach_time = 0.5 var interpolator func _ready(): interpolator = Interpolators.find_for(global_transform) func _process(delta): # Approach target node, if it exists if target_node: var from_xform = global_transform var to_xform = target_node.global_transform var factor = delta / approach_time global_transform = interpolator.call(from_xform, to_xform, factor) Custom interpolators Interpolators supports interpolators for custom data types, and even overriding built-in interpolators. Both can be done by registering an interpolator: Interpolators.register( func(a): return a is float, # Condition func(a, b, f): return lerpf(a, b, f * f) # Interpolation ) The above registers a custom interpolator by specifying a condition function and an interpolation function. Since it applies to an already supported type, it overrides the built-in interpolator. During lookup, Interpolators calls the condition function of each interpolator and returns the one whose condition function returns true. If multiple interpolators are applicable, Interpolators returns the last registered one. The interpolation function receives the starting value a , the target value b and the interpolation factor f . Built-in interpolators The following types are supported by default: float Vector2 Vector3 Transform2D Transform3D","title":"Interpolators"},{"location":"netfox/guides/interpolators/#interpolators","text":"Tracks interpolators for various data types. Provided as an autoload. To smooth out motion between network ticks, TickInterpolator interpolates nodes' state properties between the current and the previous tick. The type of data to be interpolated is not known in advance, and can be any built-in or even custom type configured by the developer. Interpolators provides methods to register interpolators for any data type, and even provides some for built-in data types.","title":"Interpolators"},{"location":"netfox/guides/interpolators/#interpolating-values","text":"Interpolators can be used to interpolate between any two values, as long as they hold the same data type: extends Node3D @export var target_node @export var approach_time = 0.5 func _process(delta): # Approach target node, if it exists if target_node: var from_xform = global_transform var to_xform = target_node.global_transform var factor = delta / approach_time global_transform = Interpolators.interpolate(from_xform, to_xform, factor) Note that in this case, Interpolators will try to look up the appropriate interpolator based on the provided values. If no interpolator is found, a fallback is used, that simply returns the value closer to factor - i.e. the starting value if factor is less than 0.5 and the target value otherwise.","title":"Interpolating values"},{"location":"netfox/guides/interpolators/#caching-interpolators","text":"To avoid having to look up the right interpolator every frame, you can cache it: extends Node3D @export target_node @export approach_time = 0.5 var interpolator func _ready(): interpolator = Interpolators.find_for(global_transform) func _process(delta): # Approach target node, if it exists if target_node: var from_xform = global_transform var to_xform = target_node.global_transform var factor = delta / approach_time global_transform = interpolator.call(from_xform, to_xform, factor)","title":"Caching interpolators"},{"location":"netfox/guides/interpolators/#custom-interpolators","text":"Interpolators supports interpolators for custom data types, and even overriding built-in interpolators. Both can be done by registering an interpolator: Interpolators.register( func(a): return a is float, # Condition func(a, b, f): return lerpf(a, b, f * f) # Interpolation ) The above registers a custom interpolator by specifying a condition function and an interpolation function. Since it applies to an already supported type, it overrides the built-in interpolator. During lookup, Interpolators calls the condition function of each interpolator and returns the one whose condition function returns true. If multiple interpolators are applicable, Interpolators returns the last registered one. The interpolation function receives the starting value a , the target value b and the interpolation factor f .","title":"Custom interpolators"},{"location":"netfox/guides/interpolators/#built-in-interpolators","text":"The following types are supported by default: float Vector2 Vector3 Transform2D Transform3D","title":"Built-in interpolators"},{"location":"netfox/guides/logging/","text":"Logging During runtime, it can be useful to print some diagnostic info to the console - this is called logging. The netfox addons include various log messages to help with debugging. This is useful when running the game locally, but also helps if there's log files players can attach with their bug reports. Depending on your game, different logs may be needed. To accommodate this, netfox can be configured to omit certain log messages. Log levels Each log message can be in one of the following categories: Error Something goes irrecoverably wrong, or something that should never happen just happened Warning Something goes wrong, but can be handled Info Useful information on expected behaviour Debug Verbose messages, to help debug general code flow Trace Extremely verbose messages, to help follow the code flow to the smallest detail Log messages Log messages from any of the netfox addons are prefixed with log level, module and logging class / object: [INF][netfox.noray::Noray] Trying to connect to noray at tomfol.io:8890 [DBG][netfox.noray::Noray] Resolved noray host to 172.105.69.73 [INF][netfox.noray::Noray] Connected to noray at 172.105.69.73:8890 [DBG][netfox.noray::Noray] Saved OID: 6JeDH07eVuFu5SO0p-6X2 [DBG][netfox.noray::Noray] Bound UDP to port 47769 [DBG][netfox.noray::Noray] Saved PID: vw6_N9sT2N0tXaYke9SV9ReWCgtdsOdfeL1o9zkCL93U7KzBjgMZ7hShBXpf_WYOB_TthARt4GfzH1iLxXR7iR3WCebzx9Sf108e8wUoqwTJqm9bIdVxyYoQUBFT9h2M [INF][netfox.noray::Noray] Registered local port 47769 to remote This makes it easier to gather info at a glance. Settings These settings control the minimum log level - e.g. if the log level is set to info , only messages at or above the info level will be logged, namely info, warning and error. If the setting is set to all , all messages are logged. Log levels can be controlled globally and per addon. A message will be logged if it passes both logging level checks. For example, if the Log Level setting is at Warning and the Netfox Log Level is at Info , only warning and error messages are logged for netfox. This happens because the Log Level is more restrictive than the Netfox Log Level setting. Note that you don't need to install all netfox addons for the logging settings to work. If an addon is not installed, its log level setting is simply ignored.","title":"Logging"},{"location":"netfox/guides/logging/#logging","text":"During runtime, it can be useful to print some diagnostic info to the console - this is called logging. The netfox addons include various log messages to help with debugging. This is useful when running the game locally, but also helps if there's log files players can attach with their bug reports. Depending on your game, different logs may be needed. To accommodate this, netfox can be configured to omit certain log messages.","title":"Logging"},{"location":"netfox/guides/logging/#log-levels","text":"Each log message can be in one of the following categories: Error Something goes irrecoverably wrong, or something that should never happen just happened Warning Something goes wrong, but can be handled Info Useful information on expected behaviour Debug Verbose messages, to help debug general code flow Trace Extremely verbose messages, to help follow the code flow to the smallest detail","title":"Log levels"},{"location":"netfox/guides/logging/#log-messages","text":"Log messages from any of the netfox addons are prefixed with log level, module and logging class / object: [INF][netfox.noray::Noray] Trying to connect to noray at tomfol.io:8890 [DBG][netfox.noray::Noray] Resolved noray host to 172.105.69.73 [INF][netfox.noray::Noray] Connected to noray at 172.105.69.73:8890 [DBG][netfox.noray::Noray] Saved OID: 6JeDH07eVuFu5SO0p-6X2 [DBG][netfox.noray::Noray] Bound UDP to port 47769 [DBG][netfox.noray::Noray] Saved PID: vw6_N9sT2N0tXaYke9SV9ReWCgtdsOdfeL1o9zkCL93U7KzBjgMZ7hShBXpf_WYOB_TthARt4GfzH1iLxXR7iR3WCebzx9Sf108e8wUoqwTJqm9bIdVxyYoQUBFT9h2M [INF][netfox.noray::Noray] Registered local port 47769 to remote This makes it easier to gather info at a glance.","title":"Log messages"},{"location":"netfox/guides/logging/#settings","text":"These settings control the minimum log level - e.g. if the log level is set to info , only messages at or above the info level will be logged, namely info, warning and error. If the setting is set to all , all messages are logged. Log levels can be controlled globally and per addon. A message will be logged if it passes both logging level checks. For example, if the Log Level setting is at Warning and the Netfox Log Level is at Info , only warning and error messages are logged for netfox. This happens because the Log Level is more restrictive than the Netfox Log Level setting. Note that you don't need to install all netfox addons for the logging settings to work. If an addon is not installed, its log level setting is simply ignored.","title":"Settings"},{"location":"netfox/guides/network-events/","text":"NetworkEvents Provides convenience signals for multiplayer games. Included as an autoload. Keeps track of the root multiplayer instance and fires signals when it changes. Using NetworkEvents ' signals are safe even when the multiplayer instance changes, as the signals are updated upon instance change. Provides missing signals for server start and server stop events. NetworkTime When enabled, NetworkEvents will start NetworkTime when it detects that a server or a client is started. It will stop NetworkTime , when it detects that the currently running server or client is stopped. Settings Settings are found in the Project Settings, under Netfox > Events: Enabled toggles network events. When disabled, NetworkEvents will not emit any events or track the multiplayer instance. This may slightly improve performance, as it completely stops Godot from processing the NetworkEvents node.","title":"NetworkEvents"},{"location":"netfox/guides/network-events/#networkevents","text":"Provides convenience signals for multiplayer games. Included as an autoload. Keeps track of the root multiplayer instance and fires signals when it changes. Using NetworkEvents ' signals are safe even when the multiplayer instance changes, as the signals are updated upon instance change. Provides missing signals for server start and server stop events.","title":"NetworkEvents"},{"location":"netfox/guides/network-events/#networktime","text":"When enabled, NetworkEvents will start NetworkTime when it detects that a server or a client is started. It will stop NetworkTime , when it detects that the currently running server or client is stopped.","title":"NetworkTime"},{"location":"netfox/guides/network-events/#settings","text":"Settings are found in the Project Settings, under Netfox > Events: Enabled toggles network events. When disabled, NetworkEvents will not emit any events or track the multiplayer instance. This may slightly improve performance, as it completely stops Godot from processing the NetworkEvents node.","title":"Settings"},{"location":"netfox/guides/network-performance/","text":"NetworkPerformance Provides custom monitors for measuring networking performance. Included as an autoload. Enabling monitoring By default, network performance monitoring is only enabled in debug builds and when running from the editor. Use the netfox_noperf feature tag to force disable network performance monitors. Use the netfox_perf feature tag to force enable network performance monitors. These feature tags enable customization for each export preset. Performance monitors Network loop duration Network loop duration measures the time spent in the network tick loop . Note that this includes time spent on the rollback loop as well. This value is updated once for every tick loop, it is not reset to zero after the loop has run. This means that you may get a non-zero reading, even if the tick loop is currently not running. Rollback loop duration Rollback loop duration measures the time spent in the last rollback loop . This includes all of its steps. The value of this monitor may be zero, if no players have joined, no nodes use rollback, or rollback is disabled. Network ticks simulated Network ticks simulated measures the number of ticks run in the last network tick loop . If the game runs at a higher FPS than the network tickrate, this value should be consistently one. Higher, stable values mean that the game itself runs slower than the network tickrate, and needs to catch up by running multiple ticks on each frame. Rollback ticks simulated Rollback ticks simulated measures the number of rollback ticks run in the last rollback loop . Generally, this denotes the age of the oldest input or state received, depending on whether the game is running as a server or client. The measurement is strongly correlated to network latency - the higher the latency, the older the state and input packets will be upon arrival. The more rollback ticks need to be simulated, the more work the rollback tick has to do, which can negatively affect performance. Rollback tick duration Rollback tick duration provides the average time spent simulating a single tick in the last rollback loop . This can be useful to determine if the rollback tick duration comes from too many ticks being simulated, or the individual ticks being expensive to simulate ( or both ).","title":"NetworkPerformance"},{"location":"netfox/guides/network-performance/#networkperformance","text":"Provides custom monitors for measuring networking performance. Included as an autoload.","title":"NetworkPerformance"},{"location":"netfox/guides/network-performance/#enabling-monitoring","text":"By default, network performance monitoring is only enabled in debug builds and when running from the editor. Use the netfox_noperf feature tag to force disable network performance monitors. Use the netfox_perf feature tag to force enable network performance monitors. These feature tags enable customization for each export preset.","title":"Enabling monitoring"},{"location":"netfox/guides/network-performance/#performance-monitors","text":"","title":"Performance monitors"},{"location":"netfox/guides/network-performance/#network-loop-duration","text":"Network loop duration measures the time spent in the network tick loop . Note that this includes time spent on the rollback loop as well. This value is updated once for every tick loop, it is not reset to zero after the loop has run. This means that you may get a non-zero reading, even if the tick loop is currently not running.","title":"Network loop duration"},{"location":"netfox/guides/network-performance/#rollback-loop-duration","text":"Rollback loop duration measures the time spent in the last rollback loop . This includes all of its steps. The value of this monitor may be zero, if no players have joined, no nodes use rollback, or rollback is disabled.","title":"Rollback loop duration"},{"location":"netfox/guides/network-performance/#network-ticks-simulated","text":"Network ticks simulated measures the number of ticks run in the last network tick loop . If the game runs at a higher FPS than the network tickrate, this value should be consistently one. Higher, stable values mean that the game itself runs slower than the network tickrate, and needs to catch up by running multiple ticks on each frame.","title":"Network ticks simulated"},{"location":"netfox/guides/network-performance/#rollback-ticks-simulated","text":"Rollback ticks simulated measures the number of rollback ticks run in the last rollback loop . Generally, this denotes the age of the oldest input or state received, depending on whether the game is running as a server or client. The measurement is strongly correlated to network latency - the higher the latency, the older the state and input packets will be upon arrival. The more rollback ticks need to be simulated, the more work the rollback tick has to do, which can negatively affect performance.","title":"Rollback ticks simulated"},{"location":"netfox/guides/network-performance/#rollback-tick-duration","text":"Rollback tick duration provides the average time spent simulating a single tick in the last rollback loop . This can be useful to determine if the rollback tick duration comes from too many ticks being simulated, or the individual ticks being expensive to simulate ( or both ).","title":"Rollback tick duration"},{"location":"netfox/guides/network-rollback/","text":"NetworkRollback Orchestrates the network rollback loop. Provided as an autoload. Due to latency, the server may receive inputs from clients from multiple ticks ago. Whenever this happens, the server rewinds its time and resimulates the whole game from the time of the new input. The resimulated ticks are then sent to clients to update their state. Also due to latency, clients may receive a state from the server that is several ticks old. Clients rewind their simulation to the time of the latest received state and resimulate from there. On both clients and servers, simulated states are recorded for reuse later. Further reading: Client-Side Prediction and Server Reconciliation Note that most of the time you do not need to use this class - the RollbackSynchronizer node helps with writing rollback-aware behaviour. Network rollback loop NetworkRollback runs the network rollback loop after every network tick, but before the after tick signal is fired. The following is the network rollback loop in isolation: Signal handlers must implement the right steps for rollback to work. During before_loop , all rollback-aware nodes must submit where to start the resimulation, by calling NetworkRollback.notify_resimulation_start . Resimulation will begin from the earliest tick submitted. In each on_prepare_tick(tick) handler, nodes must rewind their state to the specified tick. If a state is not available for the given tick, use the latest tick that is earlier than the given tick. Nodes may also register themselves as being simulated by calling NetworkRollback.notify_simulated . This is not used by NetworkRollback itself, but can be used by other nodes to check which nodes are simulated in the current rollback tick. For the on_process_tick(tick) signal, nodes must advance their simulation by a single tick. In on_record_tick(tick) , nodes must record their state for the given tick. Note that since the simulation was advanced by one tick in the previous signal, the tick parameter is incremented here. The after_loop signal notifies its subscribers that the resimulation is done. This can be used to change to the state that is appropriate for display. The network rollback loop is part of the network tick loop as follows: Conditional simulation During rollback, NetworkRollback loops over the full range of ticks to resimulate. Some nodes may not need to be resimulated for the current tick, e.g. because they don't have input for the current tick. NetworkRollback can be used to track nodes that will be simulated in the current rollback tick. Register nodes that will be simulated by calling NetworkRollback.notify_simulated . To check if a node has been registered, call NetworkRollback.is_simulated . Rollback-awareness RollbackSynchronizer considers nodes rollback-aware that implement the _rollback_tick method. Rollback-aware nodes are nodes that can participate in the rollback process, i.e. they can resimulate earlier ticks. To check if a node is rollback-aware, call NetworkRollback.is_rollback_aware . To actually run a rollback tick on them, call NetworkRollback.process_rollback . These methods are called by RollbackSynchronizer under the hood. Settings Enabled toggles network rollback. No signals are fired when disabled. History limit is the maximum number of recorded ticks to keep. Larger values enable further rewinds and thus larger latencies, but consume more memory for each node that is recorded. Input redundancy This is the number of previous input ticks to send along with the current tick. We send data unreliably over UDP for speed. In the event a packet is lost or arrives out of order we add some redundancy. You can calculate your target reliability % packet success chance by using the formula 1 - (1 - packet_success_rate) ^ input_redundancy . Display offset specifies the age of the tick to display. By displaying an older state instead of the latest one, games can mask adjustments if a state update is received from the server. The drawback is that the game will have some latency built-in, as it reacts to player inputs with some delay. Setting to zero will always display the latest game state. Enable diff states toggles diff states. By sending only state properties that have changed, netfox can reduce the bandwidth needed to synchronize the game between peers. See RollbackSynchronizer on how this is done and configured.","title":"NetworkRollback"},{"location":"netfox/guides/network-rollback/#networkrollback","text":"Orchestrates the network rollback loop. Provided as an autoload. Due to latency, the server may receive inputs from clients from multiple ticks ago. Whenever this happens, the server rewinds its time and resimulates the whole game from the time of the new input. The resimulated ticks are then sent to clients to update their state. Also due to latency, clients may receive a state from the server that is several ticks old. Clients rewind their simulation to the time of the latest received state and resimulate from there. On both clients and servers, simulated states are recorded for reuse later. Further reading: Client-Side Prediction and Server Reconciliation Note that most of the time you do not need to use this class - the RollbackSynchronizer node helps with writing rollback-aware behaviour.","title":"NetworkRollback"},{"location":"netfox/guides/network-rollback/#network-rollback-loop","text":"NetworkRollback runs the network rollback loop after every network tick, but before the after tick signal is fired. The following is the network rollback loop in isolation: Signal handlers must implement the right steps for rollback to work. During before_loop , all rollback-aware nodes must submit where to start the resimulation, by calling NetworkRollback.notify_resimulation_start . Resimulation will begin from the earliest tick submitted. In each on_prepare_tick(tick) handler, nodes must rewind their state to the specified tick. If a state is not available for the given tick, use the latest tick that is earlier than the given tick. Nodes may also register themselves as being simulated by calling NetworkRollback.notify_simulated . This is not used by NetworkRollback itself, but can be used by other nodes to check which nodes are simulated in the current rollback tick. For the on_process_tick(tick) signal, nodes must advance their simulation by a single tick. In on_record_tick(tick) , nodes must record their state for the given tick. Note that since the simulation was advanced by one tick in the previous signal, the tick parameter is incremented here. The after_loop signal notifies its subscribers that the resimulation is done. This can be used to change to the state that is appropriate for display. The network rollback loop is part of the network tick loop as follows:","title":"Network rollback loop"},{"location":"netfox/guides/network-rollback/#conditional-simulation","text":"During rollback, NetworkRollback loops over the full range of ticks to resimulate. Some nodes may not need to be resimulated for the current tick, e.g. because they don't have input for the current tick. NetworkRollback can be used to track nodes that will be simulated in the current rollback tick. Register nodes that will be simulated by calling NetworkRollback.notify_simulated . To check if a node has been registered, call NetworkRollback.is_simulated .","title":"Conditional simulation"},{"location":"netfox/guides/network-rollback/#rollback-awareness","text":"RollbackSynchronizer considers nodes rollback-aware that implement the _rollback_tick method. Rollback-aware nodes are nodes that can participate in the rollback process, i.e. they can resimulate earlier ticks. To check if a node is rollback-aware, call NetworkRollback.is_rollback_aware . To actually run a rollback tick on them, call NetworkRollback.process_rollback . These methods are called by RollbackSynchronizer under the hood.","title":"Rollback-awareness"},{"location":"netfox/guides/network-rollback/#settings","text":"Enabled toggles network rollback. No signals are fired when disabled. History limit is the maximum number of recorded ticks to keep. Larger values enable further rewinds and thus larger latencies, but consume more memory for each node that is recorded. Input redundancy This is the number of previous input ticks to send along with the current tick. We send data unreliably over UDP for speed. In the event a packet is lost or arrives out of order we add some redundancy. You can calculate your target reliability % packet success chance by using the formula 1 - (1 - packet_success_rate) ^ input_redundancy . Display offset specifies the age of the tick to display. By displaying an older state instead of the latest one, games can mask adjustments if a state update is received from the server. The drawback is that the game will have some latency built-in, as it reacts to player inputs with some delay. Setting to zero will always display the latest game state. Enable diff states toggles diff states. By sending only state properties that have changed, netfox can reduce the bandwidth needed to synchronize the game between peers. See RollbackSynchronizer on how this is done and configured.","title":"Settings"},{"location":"netfox/guides/network-time-synchronizer/","text":"NetworkTimeSynchronizer Synchronizes time to the host remote. Provided as an autoload. Synchronization is done by continuously pinging the host remote, and using these samples to figure out clock difference and network latency. These are then used to gradually adjust the local clock to keep in sync. The three clocks The process distinguishes three different clock concepts: The Remote clock is the clock being synchronized to, running on the host peer. The Reference clock is a local clock, running on the client, that is getting adjusted to match the Remote clock as closely as possible. This clock is unsuitable to use for gameplay, as it being regularly adjusted can lead to glitchy movement. The Simulation clock is also a local clock, and is being synchronized to the Reference clock. The Simulation clock is guaranteed to only move forwards in time. It drives the Network tick loop . Most of the time you shouldn't need to interface with this class directly, instead you can use NetworkTime . Synchronizing the Reference clock Synchronization is done by regularly taking samples of the remote clock, and deriving roundtrip time and clock offset from each sample. These samples are then combined into a single set of stats - offset, roundtrip time and jitter. Offset is the difference to the remote clock. Positive values mean the remote clock is ahead of the reference clock. Negative values mean that the remote clock is behind the reference clock. May also be called theta. Roundtrip time is the time it takes for data to travel to the remote and then back over the network. Smaller roundtrip times usually mean faster network connections. May also be called delay or delta. Jitter is the amount of variation in measured roundtrip times. The less jitter, the more stable the network connection usually. These stats are then used to get a good estimate of the current time on the remote clock. The remote clock estimate is then used to slowly adjust ( nudge ) the reference clock towards the remote clock's value. This is done iteratively, to avoid large jumps in time, and to - when possible - only go forward in time, not backwards. When the offset gets too significant, it means that the clocks are excessively out of sync. In these cases, a panic occurs and the reference clock is reset. This process is inspired by the NTPv4 RFC. Synchronizing the Simulation clock While the Reference clock is in sync with the Remote clock, its time is not linear - it is not guaranteed to advance monotonously, and technically it's also possible for it to move backwards. This would lead to uneven tick loops ( e.g. sometimes 3 ticks in a single loop, sometimes 1, sometimes 5), and by extension, uneven and jerky movement. To counteract the above, the Simulation clock is introduced. It is synced to the Reference clock, but instead of adjusting it by adding small offsets to it, it is stretched . Whenever the Simulation clock is ahead of the Reference clock, the it will slightly slow down, to allow the Reference clock to catch up. When the Reference clock is ahead of the Simulation clock, it will run slightly faster to catch up with the Reference clock. These stretches are subtle enough to not disturb gameplay, but effective enough to keep the two clocks in sync. The Simulation clock is handled by NetworkTime . Characteristics The above process works well regardless of latency - very similar results can be achieved with 50ms latency as with 250ms. Synchronization is more sensitive to jitter. Less stable network connections produce more varied latencies, which makes it difficult to distinguish clock offsets from latency variations. This in turn leads to the estimated clock offset changing more often, which results in more clock adjustments.","title":"NetworkTimeSynchronizer"},{"location":"netfox/guides/network-time-synchronizer/#networktimesynchronizer","text":"Synchronizes time to the host remote. Provided as an autoload. Synchronization is done by continuously pinging the host remote, and using these samples to figure out clock difference and network latency. These are then used to gradually adjust the local clock to keep in sync.","title":"NetworkTimeSynchronizer"},{"location":"netfox/guides/network-time-synchronizer/#the-three-clocks","text":"The process distinguishes three different clock concepts: The Remote clock is the clock being synchronized to, running on the host peer. The Reference clock is a local clock, running on the client, that is getting adjusted to match the Remote clock as closely as possible. This clock is unsuitable to use for gameplay, as it being regularly adjusted can lead to glitchy movement. The Simulation clock is also a local clock, and is being synchronized to the Reference clock. The Simulation clock is guaranteed to only move forwards in time. It drives the Network tick loop . Most of the time you shouldn't need to interface with this class directly, instead you can use NetworkTime .","title":"The three clocks"},{"location":"netfox/guides/network-time-synchronizer/#synchronizing-the-reference-clock","text":"Synchronization is done by regularly taking samples of the remote clock, and deriving roundtrip time and clock offset from each sample. These samples are then combined into a single set of stats - offset, roundtrip time and jitter. Offset is the difference to the remote clock. Positive values mean the remote clock is ahead of the reference clock. Negative values mean that the remote clock is behind the reference clock. May also be called theta. Roundtrip time is the time it takes for data to travel to the remote and then back over the network. Smaller roundtrip times usually mean faster network connections. May also be called delay or delta. Jitter is the amount of variation in measured roundtrip times. The less jitter, the more stable the network connection usually. These stats are then used to get a good estimate of the current time on the remote clock. The remote clock estimate is then used to slowly adjust ( nudge ) the reference clock towards the remote clock's value. This is done iteratively, to avoid large jumps in time, and to - when possible - only go forward in time, not backwards. When the offset gets too significant, it means that the clocks are excessively out of sync. In these cases, a panic occurs and the reference clock is reset. This process is inspired by the NTPv4 RFC.","title":"Synchronizing the Reference clock"},{"location":"netfox/guides/network-time-synchronizer/#synchronizing-the-simulation-clock","text":"While the Reference clock is in sync with the Remote clock, its time is not linear - it is not guaranteed to advance monotonously, and technically it's also possible for it to move backwards. This would lead to uneven tick loops ( e.g. sometimes 3 ticks in a single loop, sometimes 1, sometimes 5), and by extension, uneven and jerky movement. To counteract the above, the Simulation clock is introduced. It is synced to the Reference clock, but instead of adjusting it by adding small offsets to it, it is stretched . Whenever the Simulation clock is ahead of the Reference clock, the it will slightly slow down, to allow the Reference clock to catch up. When the Reference clock is ahead of the Simulation clock, it will run slightly faster to catch up with the Reference clock. These stretches are subtle enough to not disturb gameplay, but effective enough to keep the two clocks in sync. The Simulation clock is handled by NetworkTime .","title":"Synchronizing the Simulation clock"},{"location":"netfox/guides/network-time-synchronizer/#characteristics","text":"The above process works well regardless of latency - very similar results can be achieved with 50ms latency as with 250ms. Synchronization is more sensitive to jitter. Less stable network connections produce more varied latencies, which makes it difficult to distinguish clock offsets from latency variations. This in turn leads to the estimated clock offset changing more often, which results in more clock adjustments.","title":"Characteristics"},{"location":"netfox/guides/network-time/","text":"NetworkTime Tracks shared network time between players, and provides an event loop for synchronized game updates. Provided as an autoload. A separate timer is provided for network ticks, making the network game update rate independent from rendering or physics frames. Network tick loop NetworkTime provides its own independent event loop by exposing signals. This makes networked game logic independent of current FPS, and makes it run at a consistent rate. Connect handlers to NetworkTime 's signals to implement networked game logic. During each frame, NetworkTime checks how much time has elapsed since the last tick loop. When more time has elapsed than a single tick's duration, the network tick loop will run: The tick loop will run as long as it catches up on ticks to run. Every loop is limited to run at most max_ticks_per_frame ticks to avoid overwhelming the CPU. To tie the network tick loop to Godot's physics process, enable sync_to_physics . This will result in the tick loop running a single tick in every physics update. To move your game logic to the network tick loop, use the on_tick event: extends Node3D @export var speed = 4.0 func _ready(): NetworkTime.on_tick.connect(_tick) func _tick(delta, tick): # Move forward position += basis.z * delta * speed By convention, on_tick handlers are named _tick . Starting and stopping By default, NetworkTime does not run the tick loop at all. This lets you control when the network tick loop, and thus the game starts and stops. To start the tick loop, call the NetworkTime.start() coroutine. On servers, this will start the tick loop and return immediately. On clients, it will first synchronize the time to the server, start the network tick loop, and only then return. Use this when starting the game. Starting the tick loop before starting multiplayer is not supported. To stop the tick loop, call NetworkTime.stop() . This will immediately stop the tick loop and return. Use this when the player leaves a game. To get notified when a client successfully syncs their time and starts the tick loop, use the NetworkTime.after_client_sync(peer_id) signal. This is fired once per client, and only on the server. Pausing NetworkTime also supports pausing the game, if needed. There's two cases where pauses are considered. When running ( and pausing ) the game from the editor, the network tick loop is automatically paused. As there's currently no API to detect the editor pausing the game, NetworkTime checks if Godot's _process delta and actual delta is mismatching, and if so, considers the game paused. In some cases, this can result in false positives when the game simply hangs for a bit, e.g. when loading resources. This pause detection only happens when the game is run from the editor, to avoid false positives in production builds. The other supported case is pausing the game from the engine itself. Whenever SceneTree.paused is set to true, NetworkTime won't run the tick loop. Note that pausing the tick loop can cause desynchronization between peers, and could lead to clients fast-forwarding ticks to catch up, or time recalibrations. If the game is paused via SceneTree, make sure it is paused and unpaused at the same time on all peers. Time synchronization NetworkTime runs a time synchronization loop on clients, in the background. Synchronizing time makes sure that all players have a shared idea of time and can exchange timing-related data. The synchronization itself is handled by NetworkTimeSynchronizer . NetworkTime provides different kinds of time, each for different use cases. Each time can be accessed as ticks or seconds. Both advance after every network tick. Synchronized time NetworkTime.time NetworkTime.ticks Marks the current network game time. This is continuously synchronized, making sure that these values are as close to eachother on all peers as possible. Use this whenever a notion of game time is needed. Local time Deprecated since netfox v1.9.0. Use synchronized time instead. NetworkTime.local_time NetworkTime.local_ticks Marks the current time in reference to the local machine. Starts at zero when the network tick loop starts. Useful for logic that is tied to the tick loop, but is not synchronized over the network. A good example is visual effects. Not suitable for synchronizing data, as the local time is different at each player. Remote time Deprecated since netfox v1.9.0. Use synchronized time instead. NetworkTime.remote_ticks NetwokrTime.remote_time NetworkTime.remote_rtt Marks the current estimated time of the server. This is a regularly updated estimate. Note that on each update, the remote time may jump forwards or even backwards. The estimate is based on the measured roundtrip time ( remote_rtt ) and the assumption that the latency is exactly half of that. Can be used as a base for comparisons ( e.g. latency ), but not recommended for tying game logic to it. To get notified when a time synchronization happens and the remote time is updated, use the NetworkTime.after_sync signal. Settings Settings are found in the Project Settings, under Netfox > Time: Tickrate specifies the number of ticks every second in the network tick loop. Max Ticks Per Frame sets the maximum number of frames to simulate per tick loop. Used to avoid freezing the game under load. Recalibrate Threshold is the largest allowed time discrepancy in seconds. If the difference between the remote clock and reference clock is larger than this setting, the reference clock will be reset to the remote clock. See NetworkTimeSynchronizer for more details. Sync Interval is the resting time in seconds between sampling the remote clock. Sync Samples is the number of measurements to use for time synchronization. This includes measuring roundtrip time and estimating clock offsets. Sync Adjust Steps is the number of iterations to use when adjusting the reference clock. Larger values result in more stable clocks but slower convergence, while smaller values synchronize more aggressively. Sync Sample Interval deprecated in netfox v1.9.0 . Originally used as the resting time between roundtrip measurements. Sync to Physics ensures that the network tick loop runs in Godot's physics process when enabled. This can be useful in cases where a lot of physics operations need to be done as part of the tick- or the rollback loop.","title":"NetworkTime"},{"location":"netfox/guides/network-time/#networktime","text":"Tracks shared network time between players, and provides an event loop for synchronized game updates. Provided as an autoload. A separate timer is provided for network ticks, making the network game update rate independent from rendering or physics frames.","title":"NetworkTime"},{"location":"netfox/guides/network-time/#network-tick-loop","text":"NetworkTime provides its own independent event loop by exposing signals. This makes networked game logic independent of current FPS, and makes it run at a consistent rate. Connect handlers to NetworkTime 's signals to implement networked game logic. During each frame, NetworkTime checks how much time has elapsed since the last tick loop. When more time has elapsed than a single tick's duration, the network tick loop will run: The tick loop will run as long as it catches up on ticks to run. Every loop is limited to run at most max_ticks_per_frame ticks to avoid overwhelming the CPU. To tie the network tick loop to Godot's physics process, enable sync_to_physics . This will result in the tick loop running a single tick in every physics update. To move your game logic to the network tick loop, use the on_tick event: extends Node3D @export var speed = 4.0 func _ready(): NetworkTime.on_tick.connect(_tick) func _tick(delta, tick): # Move forward position += basis.z * delta * speed By convention, on_tick handlers are named _tick .","title":"Network tick loop"},{"location":"netfox/guides/network-time/#starting-and-stopping","text":"By default, NetworkTime does not run the tick loop at all. This lets you control when the network tick loop, and thus the game starts and stops. To start the tick loop, call the NetworkTime.start() coroutine. On servers, this will start the tick loop and return immediately. On clients, it will first synchronize the time to the server, start the network tick loop, and only then return. Use this when starting the game. Starting the tick loop before starting multiplayer is not supported. To stop the tick loop, call NetworkTime.stop() . This will immediately stop the tick loop and return. Use this when the player leaves a game. To get notified when a client successfully syncs their time and starts the tick loop, use the NetworkTime.after_client_sync(peer_id) signal. This is fired once per client, and only on the server.","title":"Starting and stopping"},{"location":"netfox/guides/network-time/#pausing","text":"NetworkTime also supports pausing the game, if needed. There's two cases where pauses are considered. When running ( and pausing ) the game from the editor, the network tick loop is automatically paused. As there's currently no API to detect the editor pausing the game, NetworkTime checks if Godot's _process delta and actual delta is mismatching, and if so, considers the game paused. In some cases, this can result in false positives when the game simply hangs for a bit, e.g. when loading resources. This pause detection only happens when the game is run from the editor, to avoid false positives in production builds. The other supported case is pausing the game from the engine itself. Whenever SceneTree.paused is set to true, NetworkTime won't run the tick loop. Note that pausing the tick loop can cause desynchronization between peers, and could lead to clients fast-forwarding ticks to catch up, or time recalibrations. If the game is paused via SceneTree, make sure it is paused and unpaused at the same time on all peers.","title":"Pausing"},{"location":"netfox/guides/network-time/#time-synchronization","text":"NetworkTime runs a time synchronization loop on clients, in the background. Synchronizing time makes sure that all players have a shared idea of time and can exchange timing-related data. The synchronization itself is handled by NetworkTimeSynchronizer . NetworkTime provides different kinds of time, each for different use cases. Each time can be accessed as ticks or seconds. Both advance after every network tick.","title":"Time synchronization"},{"location":"netfox/guides/network-time/#synchronized-time","text":"NetworkTime.time NetworkTime.ticks Marks the current network game time. This is continuously synchronized, making sure that these values are as close to eachother on all peers as possible. Use this whenever a notion of game time is needed.","title":"Synchronized time"},{"location":"netfox/guides/network-time/#local-time","text":"Deprecated since netfox v1.9.0. Use synchronized time instead. NetworkTime.local_time NetworkTime.local_ticks Marks the current time in reference to the local machine. Starts at zero when the network tick loop starts. Useful for logic that is tied to the tick loop, but is not synchronized over the network. A good example is visual effects. Not suitable for synchronizing data, as the local time is different at each player.","title":"Local time"},{"location":"netfox/guides/network-time/#remote-time","text":"Deprecated since netfox v1.9.0. Use synchronized time instead. NetworkTime.remote_ticks NetwokrTime.remote_time NetworkTime.remote_rtt Marks the current estimated time of the server. This is a regularly updated estimate. Note that on each update, the remote time may jump forwards or even backwards. The estimate is based on the measured roundtrip time ( remote_rtt ) and the assumption that the latency is exactly half of that. Can be used as a base for comparisons ( e.g. latency ), but not recommended for tying game logic to it. To get notified when a time synchronization happens and the remote time is updated, use the NetworkTime.after_sync signal.","title":"Remote time"},{"location":"netfox/guides/network-time/#settings","text":"Settings are found in the Project Settings, under Netfox > Time: Tickrate specifies the number of ticks every second in the network tick loop. Max Ticks Per Frame sets the maximum number of frames to simulate per tick loop. Used to avoid freezing the game under load. Recalibrate Threshold is the largest allowed time discrepancy in seconds. If the difference between the remote clock and reference clock is larger than this setting, the reference clock will be reset to the remote clock. See NetworkTimeSynchronizer for more details. Sync Interval is the resting time in seconds between sampling the remote clock. Sync Samples is the number of measurements to use for time synchronization. This includes measuring roundtrip time and estimating clock offsets. Sync Adjust Steps is the number of iterations to use when adjusting the reference clock. Larger values result in more stable clocks but slower convergence, while smaller values synchronize more aggressively. Sync Sample Interval deprecated in netfox v1.9.0 . Originally used as the resting time between roundtrip measurements. Sync to Physics ensures that the network tick loop runs in Godot's physics process when enabled. This can be useful in cases where a lot of physics operations need to be done as part of the tick- or the rollback loop.","title":"Settings"},{"location":"netfox/guides/property-paths/","text":"Property paths Multiple nodes have properties as their configurations. These are specified as property paths , which have a specific syntax. These nodes have a Root property. During path resolution, this Root node is taken as base for relative paths. Syntax Property paths are specified as follows: <node-path>:<property-name> Node path can be empty if it refers to a property on the root node. If specified, node path will be interpreted relative to the root node. Any valid NodePath will work as expected. Nested properties are also supported. Specify them by appending a colon and an additional property name. With Brawler as root: :position refers to the Brawler's position Input:aim refers to the Input's aim :velocity:x refers to the Brawler's velocity's X component; this is a nested property","title":"Property paths"},{"location":"netfox/guides/property-paths/#property-paths","text":"Multiple nodes have properties as their configurations. These are specified as property paths , which have a specific syntax. These nodes have a Root property. During path resolution, this Root node is taken as base for relative paths.","title":"Property paths"},{"location":"netfox/guides/property-paths/#syntax","text":"Property paths are specified as follows: <node-path>:<property-name> Node path can be empty if it refers to a property on the root node. If specified, node path will be interpreted relative to the root node. Any valid NodePath will work as expected. Nested properties are also supported. Specify them by appending a colon and an additional property name. With Brawler as root: :position refers to the Brawler's position Input:aim refers to the Input's aim :velocity:x refers to the Brawler's velocity's X component; this is a nested property","title":"Syntax"},{"location":"netfox/nodes/rollback-synchronizer/","text":"RollbackSynchronizer Manages state during the network rollback loop by hooking into NetworkRollback events. Simulates nodes as required during rollback. To read more on best practices, see Rollback caveats . Configuring state and input To use RollbackSynchronizer , add it as a child to the target node, specify the root node, and configure which properties to manage: Root specifies the root node for resolving state and input properties. Best practice dictates to add RollbackSynchronizer under its target, so Root will most often be the RollbackSynchronizer 's parent node. State properties are recorded for each tick and restored during rollback. For state, the server is the ultimate authority. Make sure that nodes containing state properties are owned by the server. Full state interval specifies how many ticks to wait between full states. If diff states are enabled, full states are only sent at specific intervals, to make sure that peers always have the correct state data. Only considered if diff states are enabled. Diff ack interval specifies how many ticks to wait between acknowledging diff states. Setting this to lower non-zero values may result in more bandwidth savings on non-changing properties, but this can be outweighed by the increased number of ack messages. Only considered if diff states are enabled. See diff states for more on how the above two settings are used. Input properties are gathered for each player and sent to the server to use for simulation. Make sure that nodes containing input properties are owned by their respective players. See Property paths on how to specify properties. Enable input broadcast toggles whether input properties are broadcast to all peers, or only to the server. The default is true to support legacy behaviour. It is recommended to turn this off to lower bandwidth and lessen the attack surface for cheating. Note that it is not recommended to have both state and input properties on the same node. Since nodes with state belong to the server, and nodes with input belong to the player, it is difficult to separate ownership on the same node. Writing rollback-aware scripts During setup, RollbackSynchronizer finds all the rollback-aware nodes under the specified root . During rollback, it will call all the rollback-aware nodes to simulate new state. To learn about rollback-awareness, see NetworkRollback . In short, implement _rollback_tick in your scripts: extends CharacterBody3D @export var speed = 4.0 @export var input: PlayerInput func _rollback_tick(delta, tick, is_fresh): velocity = input.movement.normalized() * speed velocity *= NetworkTime.physics_factor move_and_slide() Single fire events The first time a rollback tick is processed, the is_fresh parameter is set to true . This can be used to trigger animations or sounds without them being repeated each rollback event. For example to improve the client side experience a spell or weapon can play its activating sounds and animation immediately and then proceed to complete the action once server confirmation is received. Changing configuration RollbackSynchronizer has to do some setup work whenever the state or the input properties change. By default, this work is done upon instantiation. If you need to change state or input properties during runtime, make sure to call process_settings() , otherwise RollbackSynchronizer won't apply the changes. While changing configuration after instantiation is possible, it is not recommended. You may get away with it if the configuration change happens in a few ticks after instantiation. For longer periods, experiment at your own risk. Changing ownership The setup work above is also needed whenever the multiplayer authority changes of any of the nodes that have a state- or input property. Changing authority during gameplay is supported. Make sure to call process_authority() on all peers at the same time, to ensure they're on sync about ownership. This method is called automatically during instantiation and whenever process_settings() is called. When only multiplayer authority changes, call process_authority() . When the configured state- or input properties change ( i.e. different properties need to be synced ), call process_settings() . Diff states When diff states are enabled in the rollback settings , netfox will attempt to save bandwidth by only sending state properties that have changed. These changes are always based on a tick that the receiving peer has confirmed it already has. Basically we don't want to send changes compared to a tick that the peer has no knowledge about. Peers notify the host of which ticks they know about by acknowledging ( or ack'ing ) ticks. This acknowledging has two flavors. The first flavor is full states . These states contain all the state data, regardless of what changed and what has stayed the same. These ensure that peers have all the state data for a given tick. Once a full state is received, the receiving peer acknowledges that tick over a reliable channel. The second flavor is diff states . Peers may also acknowledge ticks after receiving a diff state, meaning that they have reconstructed the given state from a known earlier state and the diff state received. These are acknowledged over an unreliable channel. By using an unreliable channel, we can acknowledge diff states more often without causing any hiccups in network traffic. When diff states are disabled, netfox will always send full state data for all ticks.","title":"RollbackSynchronizer"},{"location":"netfox/nodes/rollback-synchronizer/#rollbacksynchronizer","text":"Manages state during the network rollback loop by hooking into NetworkRollback events. Simulates nodes as required during rollback. To read more on best practices, see Rollback caveats .","title":"RollbackSynchronizer"},{"location":"netfox/nodes/rollback-synchronizer/#configuring-state-and-input","text":"To use RollbackSynchronizer , add it as a child to the target node, specify the root node, and configure which properties to manage: Root specifies the root node for resolving state and input properties. Best practice dictates to add RollbackSynchronizer under its target, so Root will most often be the RollbackSynchronizer 's parent node. State properties are recorded for each tick and restored during rollback. For state, the server is the ultimate authority. Make sure that nodes containing state properties are owned by the server. Full state interval specifies how many ticks to wait between full states. If diff states are enabled, full states are only sent at specific intervals, to make sure that peers always have the correct state data. Only considered if diff states are enabled. Diff ack interval specifies how many ticks to wait between acknowledging diff states. Setting this to lower non-zero values may result in more bandwidth savings on non-changing properties, but this can be outweighed by the increased number of ack messages. Only considered if diff states are enabled. See diff states for more on how the above two settings are used. Input properties are gathered for each player and sent to the server to use for simulation. Make sure that nodes containing input properties are owned by their respective players. See Property paths on how to specify properties. Enable input broadcast toggles whether input properties are broadcast to all peers, or only to the server. The default is true to support legacy behaviour. It is recommended to turn this off to lower bandwidth and lessen the attack surface for cheating. Note that it is not recommended to have both state and input properties on the same node. Since nodes with state belong to the server, and nodes with input belong to the player, it is difficult to separate ownership on the same node.","title":"Configuring state and input"},{"location":"netfox/nodes/rollback-synchronizer/#writing-rollback-aware-scripts","text":"During setup, RollbackSynchronizer finds all the rollback-aware nodes under the specified root . During rollback, it will call all the rollback-aware nodes to simulate new state. To learn about rollback-awareness, see NetworkRollback . In short, implement _rollback_tick in your scripts: extends CharacterBody3D @export var speed = 4.0 @export var input: PlayerInput func _rollback_tick(delta, tick, is_fresh): velocity = input.movement.normalized() * speed velocity *= NetworkTime.physics_factor move_and_slide()","title":"Writing rollback-aware scripts"},{"location":"netfox/nodes/rollback-synchronizer/#single-fire-events","text":"The first time a rollback tick is processed, the is_fresh parameter is set to true . This can be used to trigger animations or sounds without them being repeated each rollback event. For example to improve the client side experience a spell or weapon can play its activating sounds and animation immediately and then proceed to complete the action once server confirmation is received.","title":"Single fire events"},{"location":"netfox/nodes/rollback-synchronizer/#changing-configuration","text":"RollbackSynchronizer has to do some setup work whenever the state or the input properties change. By default, this work is done upon instantiation. If you need to change state or input properties during runtime, make sure to call process_settings() , otherwise RollbackSynchronizer won't apply the changes. While changing configuration after instantiation is possible, it is not recommended. You may get away with it if the configuration change happens in a few ticks after instantiation. For longer periods, experiment at your own risk.","title":"Changing configuration"},{"location":"netfox/nodes/rollback-synchronizer/#changing-ownership","text":"The setup work above is also needed whenever the multiplayer authority changes of any of the nodes that have a state- or input property. Changing authority during gameplay is supported. Make sure to call process_authority() on all peers at the same time, to ensure they're on sync about ownership. This method is called automatically during instantiation and whenever process_settings() is called. When only multiplayer authority changes, call process_authority() . When the configured state- or input properties change ( i.e. different properties need to be synced ), call process_settings() .","title":"Changing ownership"},{"location":"netfox/nodes/rollback-synchronizer/#diff-states","text":"When diff states are enabled in the rollback settings , netfox will attempt to save bandwidth by only sending state properties that have changed. These changes are always based on a tick that the receiving peer has confirmed it already has. Basically we don't want to send changes compared to a tick that the peer has no knowledge about. Peers notify the host of which ticks they know about by acknowledging ( or ack'ing ) ticks. This acknowledging has two flavors. The first flavor is full states . These states contain all the state data, regardless of what changed and what has stayed the same. These ensure that peers have all the state data for a given tick. Once a full state is received, the receiving peer acknowledges that tick over a reliable channel. The second flavor is diff states . Peers may also acknowledge ticks after receiving a diff state, meaning that they have reconstructed the given state from a known earlier state and the diff state received. These are acknowledged over an unreliable channel. By using an unreliable channel, we can acknowledge diff states more often without causing any hiccups in network traffic. When diff states are disabled, netfox will always send full state data for all ticks.","title":"Diff states"},{"location":"netfox/nodes/state-synchronizer/","text":"StateSynchronizer Synchronizes state from the node's authority to other peers. Similar to Godot's MultiplayerSynchronizer , but is tied to the network tick loop . Works well with TickInterpolator . One way to use this node is to synchronize logic that runs only on the server, for example NPC's in your games. The NPC's are controlled fully by the server, and their state is synchronized to the clients by the StateSynchronizer nodes. Configuring state To use StateSynchronizer , add it as a child to the target node, specify the root node, and configure which properties to synchronize: Root specifies the root node for resolving properties. Best practice dictates to add StateSynchronizer under its target, so Root will most often be the StateSynchronizer 's parent node. Properties are recorded for each tick on the node's authority ( usually the server ), and broadcast to other peers. These are analogous to RollbackSynchronizer 's state properties . See Property paths on how to specify properties. Changing configuration StateSynchronizer has to do some setup work whenever the state or the input properties change. By default, this work is done upon instantiation. If you need to change properties during runtime, make sure to call process_settings() , otherwise StateSynchronizer won't apply the changes. You can change the node's authority without calling process_settings() again. Make sure that the authority is changed the same way on all peers, to avoid discrepancies. When to use StateSynchronizer and MultiplayerSynchronizer Part of the design philosophy of netfox is to build on top of Godot's networking tools, instead of replacing them. Both MultiplayerSynchronizer and StateSynchronizer can be used to synchronize state from authority to the rest of the peers. MultiplayerSynchronizer uses its own timer, and is independent of netfox's network tick loop . It can also do delta updates, and manage visibility per peer. Since it is not tied to netfox's tick loop, it does not work with TickInterpolator . StateSynchronizer records all the properties specified and broadcasts them as-is to all peers. This does not include visiblity or delta updates. The broadcast happens on every network tick. This node is explicitly designed to work with TickInterpolator . You can use StateSynchronizer for properties that you want to be interpolated, like position, rotation, or any other visual properties. You can use MultiplayerSynchronizer for properties that either don't need interpolation ( e.g. a unit's HP ), or specifically need one of MultiplayerSynchronizer 's features.","title":"StateSynchronizer"},{"location":"netfox/nodes/state-synchronizer/#statesynchronizer","text":"Synchronizes state from the node's authority to other peers. Similar to Godot's MultiplayerSynchronizer , but is tied to the network tick loop . Works well with TickInterpolator . One way to use this node is to synchronize logic that runs only on the server, for example NPC's in your games. The NPC's are controlled fully by the server, and their state is synchronized to the clients by the StateSynchronizer nodes.","title":"StateSynchronizer"},{"location":"netfox/nodes/state-synchronizer/#configuring-state","text":"To use StateSynchronizer , add it as a child to the target node, specify the root node, and configure which properties to synchronize: Root specifies the root node for resolving properties. Best practice dictates to add StateSynchronizer under its target, so Root will most often be the StateSynchronizer 's parent node. Properties are recorded for each tick on the node's authority ( usually the server ), and broadcast to other peers. These are analogous to RollbackSynchronizer 's state properties . See Property paths on how to specify properties.","title":"Configuring state"},{"location":"netfox/nodes/state-synchronizer/#changing-configuration","text":"StateSynchronizer has to do some setup work whenever the state or the input properties change. By default, this work is done upon instantiation. If you need to change properties during runtime, make sure to call process_settings() , otherwise StateSynchronizer won't apply the changes. You can change the node's authority without calling process_settings() again. Make sure that the authority is changed the same way on all peers, to avoid discrepancies.","title":"Changing configuration"},{"location":"netfox/nodes/state-synchronizer/#when-to-use-statesynchronizer-and-multiplayersynchronizer","text":"Part of the design philosophy of netfox is to build on top of Godot's networking tools, instead of replacing them. Both MultiplayerSynchronizer and StateSynchronizer can be used to synchronize state from authority to the rest of the peers. MultiplayerSynchronizer uses its own timer, and is independent of netfox's network tick loop . It can also do delta updates, and manage visibility per peer. Since it is not tied to netfox's tick loop, it does not work with TickInterpolator . StateSynchronizer records all the properties specified and broadcasts them as-is to all peers. This does not include visiblity or delta updates. The broadcast happens on every network tick. This node is explicitly designed to work with TickInterpolator . You can use StateSynchronizer for properties that you want to be interpolated, like position, rotation, or any other visual properties. You can use MultiplayerSynchronizer for properties that either don't need interpolation ( e.g. a unit's HP ), or specifically need one of MultiplayerSynchronizer 's features.","title":"When to use StateSynchronizer and MultiplayerSynchronizer"},{"location":"netfox/nodes/tick-interpolator/","text":"TickInterpolator Interpolates between network ticks to smooth out motion. Uses Interpolators under the hood to support various data types. To read more on best practices, see Interpolation caveats . Configuring interpolation To use TickInterpolator , add it as a child to the target node, specify the root node, and configure which properties to interpolate: Root specifies the root node for resolving Properties . Best practice dictates to add TickInterpolator under its target, so Root will most often be the TickInterpolator 's parent node. Properties specify which properties to interpolate. See Property paths on how to specify these values. Record First State will make TickInterpolator take a snapshot when the Node is instantiated. This snapshot will be used for interpolation, instead of waiting for the next network tick. Useful for objects which start moving instantly upon entering the scene tree, like projectiles. Enable Recording toggles automatic state recording. When enabled, TickInterpolator will take a new snapshot after each network tick loop and interpolate towards that. Disabling this will require you to manually call push_state() whenever the properties are updated. Sudden changes When a node makes a sudden change, like teleporting from one place to another, interpolation may not be desired. Call teleport() in these cases to avoid interpolation and just jump to the current state. Interpolation will resume after the current state. Example: func _tick(tick, delta): # Respawn after a while if _tick == respawn_tick: # Jump to spawn point, without interpolation position = spawn_position $TickInterpolator.teleport() Changing configuration TickInterpolator has to do some setup work whenever the interpolated properties change, e.g. when a new property needs to be interpolated. By default, this work is done upon instantiation. If you need to change interpolated properties during runtime, make sure to call process_settings() , otherwise TickInterpolator won't apply the changes.","title":"TickInterpolator"},{"location":"netfox/nodes/tick-interpolator/#tickinterpolator","text":"Interpolates between network ticks to smooth out motion. Uses Interpolators under the hood to support various data types. To read more on best practices, see Interpolation caveats .","title":"TickInterpolator"},{"location":"netfox/nodes/tick-interpolator/#configuring-interpolation","text":"To use TickInterpolator , add it as a child to the target node, specify the root node, and configure which properties to interpolate: Root specifies the root node for resolving Properties . Best practice dictates to add TickInterpolator under its target, so Root will most often be the TickInterpolator 's parent node. Properties specify which properties to interpolate. See Property paths on how to specify these values. Record First State will make TickInterpolator take a snapshot when the Node is instantiated. This snapshot will be used for interpolation, instead of waiting for the next network tick. Useful for objects which start moving instantly upon entering the scene tree, like projectiles. Enable Recording toggles automatic state recording. When enabled, TickInterpolator will take a new snapshot after each network tick loop and interpolate towards that. Disabling this will require you to manually call push_state() whenever the properties are updated.","title":"Configuring interpolation"},{"location":"netfox/nodes/tick-interpolator/#sudden-changes","text":"When a node makes a sudden change, like teleporting from one place to another, interpolation may not be desired. Call teleport() in these cases to avoid interpolation and just jump to the current state. Interpolation will resume after the current state. Example: func _tick(tick, delta): # Respawn after a while if _tick == respawn_tick: # Jump to spawn point, without interpolation position = spawn_position $TickInterpolator.teleport()","title":"Sudden changes"},{"location":"netfox/nodes/tick-interpolator/#changing-configuration","text":"TickInterpolator has to do some setup work whenever the interpolated properties change, e.g. when a new property needs to be interpolated. By default, this work is done upon instantiation. If you need to change interpolated properties during runtime, make sure to call process_settings() , otherwise TickInterpolator won't apply the changes.","title":"Changing configuration"},{"location":"netfox/tutorials/interpolation-caveats/","text":"Interpolation caveats While netfox runs netcode at a fixed rate, the game may render frames at a higher, varying framerate. Interpolation smooths out the difference between tickrate and framerate, when using TickInterpolator . Below are some aspects that may catch users off guard. Interpolate only visuals A node's state may consist of multiple properties, some of which affect its appearance ( e.g. position, rotation, scale ), some are only relevant to the simulation - e.g. most objects look the same regardless of their velocity, even though it's important for simulating their behavior. Since interpolation matters only for the game's visuals, it's enough to interpolate only the properties that affect the game's visuals. Rotation vs. Quaternion vs. Transform Interpolating rotation may lead to glitchy results when an object makes a full turn. This stems from the way rotation works - it represents the amount of rotation per axis, in Euler angles. Using Euler angles to interpolate rotations doesn't work well, as they can end up interpolating from -180 degrees to +180 numerically. The expected behavior would be to go from -180 to +180 instantly, since they represent the same rotation. The same thing happens in animation software as well, when trying to interpolate with Euler angles. What to do instead: Interpolate the whole transform Interpolate quaternion - represents rotation, but better suited to interpolation For more, see Godot docs on 3D transforms","title":"Interpolation caveats"},{"location":"netfox/tutorials/interpolation-caveats/#interpolation-caveats","text":"While netfox runs netcode at a fixed rate, the game may render frames at a higher, varying framerate. Interpolation smooths out the difference between tickrate and framerate, when using TickInterpolator . Below are some aspects that may catch users off guard.","title":"Interpolation caveats"},{"location":"netfox/tutorials/interpolation-caveats/#interpolate-only-visuals","text":"A node's state may consist of multiple properties, some of which affect its appearance ( e.g. position, rotation, scale ), some are only relevant to the simulation - e.g. most objects look the same regardless of their velocity, even though it's important for simulating their behavior. Since interpolation matters only for the game's visuals, it's enough to interpolate only the properties that affect the game's visuals.","title":"Interpolate only visuals"},{"location":"netfox/tutorials/interpolation-caveats/#rotation-vs-quaternion-vs-transform","text":"Interpolating rotation may lead to glitchy results when an object makes a full turn. This stems from the way rotation works - it represents the amount of rotation per axis, in Euler angles. Using Euler angles to interpolate rotations doesn't work well, as they can end up interpolating from -180 degrees to +180 numerically. The expected behavior would be to go from -180 to +180 instantly, since they represent the same rotation. The same thing happens in animation software as well, when trying to interpolate with Euler angles. What to do instead: Interpolate the whole transform Interpolate quaternion - represents rotation, but better suited to interpolation For more, see Godot docs on 3D transforms","title":"Rotation vs. Quaternion vs. Transform"},{"location":"netfox/tutorials/responsive-player-movement/","text":"Responsive player movement To compensate for latency, netfox implements Client-side prediction and Server reconciliation . This documentation also refers to it as rollback. One use case is player movement - with CSP we don't need to wait for the server's response before the player's avatar can be updated. Gathering input For CSP, input is separated from player state. In practice, this means that there's a separate node with its own script that manages input. The job of this script is to manage properties related to input - for example, which direction the player wants to move: extends Node class_name PlayerInput var movement = Vector3.ZERO These input properties must be updated based on player input. Hook into the network tick loop 's before_tick_loop signal to update input properties: func _ready(): NetworkTime.before_tick_loop.connect(_gather) func _gather(): if not is_multiplayer_authority(): return movement = Vector3( Input.get_axis(\"move_west\", \"move_east\"), Input.get_action_strength(\"move_jump\"), Input.get_axis(\"move_north\", \"move_south\") ) It is important to only update input properties if we have authority over the node. Otherwise we would try to change some other player's input with our own actions. Using BaseNetInput The same can be accomplished with BaseNetInput , with slightly less code: extends BaseNetInput class_name PlayerInput var movement: Vector3 = Vector3.ZERO func _gather(): movement = Vector3( Input.get_axis(\"move_west\", \"move_east\"), Input.get_action_strength(\"move_jump\"), Input.get_axis(\"move_north\", \"move_south\") ) Applying movement The other part of the equation is state . Use the same approach as you would with your character controller, with the game logic being implemented in _rollback_tick instead of _process or _physics_process : extends CharacterBody3D @export var speed = 4.0 @export var input: PlayerInput func _rollback_tick(delta, tick, is_fresh): velocity = input.movement.normalized() * speed velocity *= NetworkTime.physics_factor move_and_slide() Note the usage of physics_factor - this is explained in the caveats . Configuring rollback Create a reusable player scene with the following layout: The root is a CharacterBody3D with the player controller script attached. The Input child manages player input and has the player input script attached. The RollbackSynchronizer node manages the rollback logic, making the player motion responsive while also keeping it server-authoritative . Configure the RollbackSynchronizer with the following input- and state properties: Ownership Make sure that all of the player nodes are owned by the server. The exception is the Input node, which must be owned by the player who the avatar belongs to. After setting ownerships, make sure to call process_settings on RollbackSynchronizer . This call is necessary after every ownership change. RollbackSynchronizer sorts properties based on ownership, but this sorting is only done in process_settings . For example: @onready var rollback_synchronizer = $RollbackSynchronizer var peer_id = 0 func _ready(): # Wait a frame so peer_id is set await get_tree().process_frame # Set owner set_multiplayer_authority(1) input.set_multiplayer_authority(peer_id) rollback_synchronizer.process_settings() Note that peer_id needs to be set from the outside during spawn. Smooth motion Currently, state is only updated on network ticks. If the tickrate is less than the FPS the game is running on, motion may get choppy. Add a TickInterpolator node and configure it with the same state properties as the RollbackSynchronizer : This will ensure smooth motion, regardless of FPS and tickrate.","title":"Responsive player movement"},{"location":"netfox/tutorials/responsive-player-movement/#responsive-player-movement","text":"To compensate for latency, netfox implements Client-side prediction and Server reconciliation . This documentation also refers to it as rollback. One use case is player movement - with CSP we don't need to wait for the server's response before the player's avatar can be updated.","title":"Responsive player movement"},{"location":"netfox/tutorials/responsive-player-movement/#gathering-input","text":"For CSP, input is separated from player state. In practice, this means that there's a separate node with its own script that manages input. The job of this script is to manage properties related to input - for example, which direction the player wants to move: extends Node class_name PlayerInput var movement = Vector3.ZERO These input properties must be updated based on player input. Hook into the network tick loop 's before_tick_loop signal to update input properties: func _ready(): NetworkTime.before_tick_loop.connect(_gather) func _gather(): if not is_multiplayer_authority(): return movement = Vector3( Input.get_axis(\"move_west\", \"move_east\"), Input.get_action_strength(\"move_jump\"), Input.get_axis(\"move_north\", \"move_south\") ) It is important to only update input properties if we have authority over the node. Otherwise we would try to change some other player's input with our own actions.","title":"Gathering input"},{"location":"netfox/tutorials/responsive-player-movement/#using-basenetinput","text":"The same can be accomplished with BaseNetInput , with slightly less code: extends BaseNetInput class_name PlayerInput var movement: Vector3 = Vector3.ZERO func _gather(): movement = Vector3( Input.get_axis(\"move_west\", \"move_east\"), Input.get_action_strength(\"move_jump\"), Input.get_axis(\"move_north\", \"move_south\") )","title":"Using BaseNetInput"},{"location":"netfox/tutorials/responsive-player-movement/#applying-movement","text":"The other part of the equation is state . Use the same approach as you would with your character controller, with the game logic being implemented in _rollback_tick instead of _process or _physics_process : extends CharacterBody3D @export var speed = 4.0 @export var input: PlayerInput func _rollback_tick(delta, tick, is_fresh): velocity = input.movement.normalized() * speed velocity *= NetworkTime.physics_factor move_and_slide() Note the usage of physics_factor - this is explained in the caveats .","title":"Applying movement"},{"location":"netfox/tutorials/responsive-player-movement/#configuring-rollback","text":"Create a reusable player scene with the following layout: The root is a CharacterBody3D with the player controller script attached. The Input child manages player input and has the player input script attached. The RollbackSynchronizer node manages the rollback logic, making the player motion responsive while also keeping it server-authoritative . Configure the RollbackSynchronizer with the following input- and state properties:","title":"Configuring rollback"},{"location":"netfox/tutorials/responsive-player-movement/#ownership","text":"Make sure that all of the player nodes are owned by the server. The exception is the Input node, which must be owned by the player who the avatar belongs to. After setting ownerships, make sure to call process_settings on RollbackSynchronizer . This call is necessary after every ownership change. RollbackSynchronizer sorts properties based on ownership, but this sorting is only done in process_settings . For example: @onready var rollback_synchronizer = $RollbackSynchronizer var peer_id = 0 func _ready(): # Wait a frame so peer_id is set await get_tree().process_frame # Set owner set_multiplayer_authority(1) input.set_multiplayer_authority(peer_id) rollback_synchronizer.process_settings() Note that peer_id needs to be set from the outside during spawn.","title":"Ownership"},{"location":"netfox/tutorials/responsive-player-movement/#smooth-motion","text":"Currently, state is only updated on network ticks. If the tickrate is less than the FPS the game is running on, motion may get choppy. Add a TickInterpolator node and configure it with the same state properties as the RollbackSynchronizer : This will ensure smooth motion, regardless of FPS and tickrate.","title":"Smooth motion"},{"location":"netfox/tutorials/rollback-caveats/","text":"Rollback caveats As with most things, rollback has some drawbacks along with its benefits. CharacterBody velocity Godot's move_and_slide() uses the velocity property, which is set in meters/second. The method assumes a delta time based on what kind of frame is being run. However, it is not aware of netfox 's network ticks, which means that movement speed will be off. To counteract this, multiply velocity with NetworkTime.physics_factor , which will adjust for the difference between Godot's assumed delta time and the delta time netfox is using. If you don't want to lose your original velocity ( e.g. because it accumulates acceleration over time ), divide by the same property after using any built-in method. For example: # Apply movement velocity *= NetworkTime.physics_factor move_and_slide() velocity /= NetworkTime.physics_factor CharacterBody on floor CharacterBodies only update their is_on_floor() state only after a move_and_slide() call. This means that during rollback, the position is updated, but the is_on_floor() state is not. As a work-around, do a zero-velocity move before checking if the node is on the floor: extends CharacterBody3D func _rollback_tick(delta, tick, is_fresh): # Add the gravity. _force_update_is_on_floor() if not is_on_floor(): velocity.y -= gravity * delta # ... func _force_update_is_on_floor(): var old_velocity = velocity velocity = Vector3.ZERO move_and_slide() velocity = old_velocity Physics updates Godot's physics system is updated only during _physics_process , while rollback updates the game state multiple times during a single frame. Unfortunately, Godot does not support manually updating or stepping the physics system, at least at the time of writing . This means that: Rollback and physics-based games ( RigidBodies ) don't work at the moment Collision detection can work, but with workarounds If there's a way to force an update for your given node type, it should work, i.e. ShapeCast (2D and 3D) - force_shapecast_update() ChacacterBody (2D and 3D) - move_and_collide() ( which has a test only mode ) State Machines State machines don't usually expect to be updated multiple times in a single frame or be snapped back to a previous point in time. Be cautious of: Safeguards that implement a cooldown to changes. States based on values not updated in _rollback_tick . Transitions that enforce a specific order to state changes. Transitions that trigger on any state change. The key concept to keep in mind is that netfox stores the configured states for each processed tick. When it rolls back everything is snapped back to that point in time and then played forward to the present in a single frame.","title":"Rollback caveats"},{"location":"netfox/tutorials/rollback-caveats/#rollback-caveats","text":"As with most things, rollback has some drawbacks along with its benefits.","title":"Rollback caveats"},{"location":"netfox/tutorials/rollback-caveats/#characterbody-velocity","text":"Godot's move_and_slide() uses the velocity property, which is set in meters/second. The method assumes a delta time based on what kind of frame is being run. However, it is not aware of netfox 's network ticks, which means that movement speed will be off. To counteract this, multiply velocity with NetworkTime.physics_factor , which will adjust for the difference between Godot's assumed delta time and the delta time netfox is using. If you don't want to lose your original velocity ( e.g. because it accumulates acceleration over time ), divide by the same property after using any built-in method. For example: # Apply movement velocity *= NetworkTime.physics_factor move_and_slide() velocity /= NetworkTime.physics_factor","title":"CharacterBody velocity"},{"location":"netfox/tutorials/rollback-caveats/#characterbody-on-floor","text":"CharacterBodies only update their is_on_floor() state only after a move_and_slide() call. This means that during rollback, the position is updated, but the is_on_floor() state is not. As a work-around, do a zero-velocity move before checking if the node is on the floor: extends CharacterBody3D func _rollback_tick(delta, tick, is_fresh): # Add the gravity. _force_update_is_on_floor() if not is_on_floor(): velocity.y -= gravity * delta # ... func _force_update_is_on_floor(): var old_velocity = velocity velocity = Vector3.ZERO move_and_slide() velocity = old_velocity","title":"CharacterBody on floor"},{"location":"netfox/tutorials/rollback-caveats/#physics-updates","text":"Godot's physics system is updated only during _physics_process , while rollback updates the game state multiple times during a single frame. Unfortunately, Godot does not support manually updating or stepping the physics system, at least at the time of writing . This means that: Rollback and physics-based games ( RigidBodies ) don't work at the moment Collision detection can work, but with workarounds If there's a way to force an update for your given node type, it should work, i.e. ShapeCast (2D and 3D) - force_shapecast_update() ChacacterBody (2D and 3D) - move_and_collide() ( which has a test only mode )","title":"Physics updates"},{"location":"netfox/tutorials/rollback-caveats/#state-machines","text":"State machines don't usually expect to be updated multiple times in a single frame or be snapped back to a previous point in time. Be cautious of: Safeguards that implement a cooldown to changes. States based on values not updated in _rollback_tick . Transitions that enforce a specific order to state changes. Transitions that trigger on any state change. The key concept to keep in mind is that netfox stores the configured states for each processed tick. When it rolls back everything is snapped back to that point in time and then played forward to the present in a single frame.","title":"State Machines"},{"location":"netfox.extras/guides/base-net-input/","text":"BaseNetInput Base class for Input nodes used with rollback. During rollback, multiple logical ticks are simulated in the span of a single network tick. Since these are just logical ticks, no actual input arrives during them from the input devices. The solution is to gather input before the tick loop, and use that input for any new ticks simulated during the rollback. Gathering input This class provides a virtual _gather method that you can override. Set the variables configured in RollbackSynchronizer in your own implementation: extends BaseNetInput var movement: Vector3 = Vector3.ZERO func _gather(): movement = Vector3( Input.get_axis(\"move_west\", \"move_east\"), 0, Input.get_axis(\"move_north\", \"move_south\") )","title":"BaseNetInput"},{"location":"netfox.extras/guides/base-net-input/#basenetinput","text":"Base class for Input nodes used with rollback. During rollback, multiple logical ticks are simulated in the span of a single network tick. Since these are just logical ticks, no actual input arrives during them from the input devices. The solution is to gather input before the tick loop, and use that input for any new ticks simulated during the rollback.","title":"BaseNetInput"},{"location":"netfox.extras/guides/base-net-input/#gathering-input","text":"This class provides a virtual _gather method that you can override. Set the variables configured in RollbackSynchronizer in your own implementation: extends BaseNetInput var movement: Vector3 = Vector3.ZERO func _gather(): movement = Vector3( Input.get_axis(\"move_west\", \"move_east\"), 0, Input.get_axis(\"move_north\", \"move_south\") )","title":"Gathering input"},{"location":"netfox.extras/guides/network-weapon/","text":"NetworkWeapon Class to simplify writing networked weapons. A weapon, in this context, is anything that can be fired and spawn objects ( projectiles ) upon being fired. Responsive projectiles Upon firing, sending a request to the server and waiting for the response with the projectile would introduce a delay. Doing a full-on state synchronization with MultiplayerSynchronizer or RollbackSynchronizer can be unfeasible with too many projectiles, and unnecessary, since most of the time, projectiles act and move the same way regardless of their surroundings. Instead, upon firing, a projectile is spawned instantly. At the same time, a request is sent to the server. If the server accepts the projectile, it will spawn it and broadcasts its starting state. Since the server's state is the source of truth, the projectile's local state will be updated with the difference. This is called reconciliation . If the client requests a projectile with an unlikely state, it will be rejected. This is to avoid players cheating, for example by requesting projectiles at a more advantageous position than they're at. If the server is too strict with what difference is considered acceptable and what not, legitimate players may get cases where they fire a projectile which disappears after a short time period. Implementing a weapon NetworkWeapon provides multiple functions to override. Make sure that all these methods work the same way on every player's game, otherwise players will experience glitches. _can_fire returns a bool, indicating whether the weapon can be fired. For example, this method can return false if the weapon was fired recently and is still on cooldown. Do not update state here. Use _after_fire instead. _can_peer_use indicates whether a given peer can fire the weapon. Due to the way RPCs are set up under the hood, any of the players can try to fire a weapon. Use this method to check if the player trying to fire has permission, e.g. a player is not trying to use someone else's weapon. _after_fire is called after the weapon is successfully fired. Can be used to update state ( e.g. last time the weapon was fired ) and play sound effects. _spawn creates the projectile. Make sure to return the created node. _get_data must return the projectile's starting state in a dictionary. This can contain any property that is relevant to the projectile and must be synchronized. For example, global_transform is important to ensure that the projectile starts from the right position. On the other hand, projectile speed does not need to be captured if it's the same for every projectile. _apply_data must apply the captured properties to a projectile. _is_reconcilable checks if the difference between two projectile states ( as captured by _get_data ) is close enough to be allowed. Can be used to reject cheating. _reconcile adjusts the projectile based on the difference between the local and server state. Specializations NetworkWeapon extends Node . This also means that anything extending NetworkWeapon is also a node, and thus can't have a position for example. Two specialized classes are provided - NetworkWeapon3D , and NetworkWeapon2D - extending Node3D and Node2D respectively. This way, weapons can have transforms and have a presence in the game world. They also take care of reconciliation, implementing _get_data , _apply_data , _is_reconcilable , and _reconcile . These can be overridden, but make sure to to call the base class with super(...) . Reconciliation is based on distance, and can be configured with the distance_threshold property. Under the hood, these specializations create a special NetworkWeapon node, that proxies all the method calls back to the specialization. This is a workaround to build multiple inheritance in a single inheritance language.","title":"NetworkWeapon"},{"location":"netfox.extras/guides/network-weapon/#networkweapon","text":"Class to simplify writing networked weapons. A weapon, in this context, is anything that can be fired and spawn objects ( projectiles ) upon being fired.","title":"NetworkWeapon"},{"location":"netfox.extras/guides/network-weapon/#responsive-projectiles","text":"Upon firing, sending a request to the server and waiting for the response with the projectile would introduce a delay. Doing a full-on state synchronization with MultiplayerSynchronizer or RollbackSynchronizer can be unfeasible with too many projectiles, and unnecessary, since most of the time, projectiles act and move the same way regardless of their surroundings. Instead, upon firing, a projectile is spawned instantly. At the same time, a request is sent to the server. If the server accepts the projectile, it will spawn it and broadcasts its starting state. Since the server's state is the source of truth, the projectile's local state will be updated with the difference. This is called reconciliation . If the client requests a projectile with an unlikely state, it will be rejected. This is to avoid players cheating, for example by requesting projectiles at a more advantageous position than they're at. If the server is too strict with what difference is considered acceptable and what not, legitimate players may get cases where they fire a projectile which disappears after a short time period.","title":"Responsive projectiles"},{"location":"netfox.extras/guides/network-weapon/#implementing-a-weapon","text":"NetworkWeapon provides multiple functions to override. Make sure that all these methods work the same way on every player's game, otherwise players will experience glitches. _can_fire returns a bool, indicating whether the weapon can be fired. For example, this method can return false if the weapon was fired recently and is still on cooldown. Do not update state here. Use _after_fire instead. _can_peer_use indicates whether a given peer can fire the weapon. Due to the way RPCs are set up under the hood, any of the players can try to fire a weapon. Use this method to check if the player trying to fire has permission, e.g. a player is not trying to use someone else's weapon. _after_fire is called after the weapon is successfully fired. Can be used to update state ( e.g. last time the weapon was fired ) and play sound effects. _spawn creates the projectile. Make sure to return the created node. _get_data must return the projectile's starting state in a dictionary. This can contain any property that is relevant to the projectile and must be synchronized. For example, global_transform is important to ensure that the projectile starts from the right position. On the other hand, projectile speed does not need to be captured if it's the same for every projectile. _apply_data must apply the captured properties to a projectile. _is_reconcilable checks if the difference between two projectile states ( as captured by _get_data ) is close enough to be allowed. Can be used to reject cheating. _reconcile adjusts the projectile based on the difference between the local and server state.","title":"Implementing a weapon"},{"location":"netfox.extras/guides/network-weapon/#specializations","text":"NetworkWeapon extends Node . This also means that anything extending NetworkWeapon is also a node, and thus can't have a position for example. Two specialized classes are provided - NetworkWeapon3D , and NetworkWeapon2D - extending Node3D and Node2D respectively. This way, weapons can have transforms and have a presence in the game world. They also take care of reconciliation, implementing _get_data , _apply_data , _is_reconcilable , and _reconcile . These can be overridden, but make sure to to call the base class with super(...) . Reconciliation is based on distance, and can be configured with the distance_threshold property. Under the hood, these specializations create a special NetworkWeapon node, that proxies all the method calls back to the specialization. This is a workaround to build multiple inheritance in a single inheritance language.","title":"Specializations"},{"location":"netfox.extras/guides/rewindable-state-machine/","text":"RewindableStateMachine Rollback-aware state machine implementation. State machines are often used in games to implement different behaviors. However, most implementations are not prepared for rollbacks. This class provides an extensible implementation that can be used alongside a RollbackSynchronizer . For a full example, see multiplayer-state-machine . Creating a state machine The first step is to add the RewindableStateMachine to your scene. It also requires a RollbackSynchronizer that manages its state property. Unless these conditions are satisfied, an editor warning will be displayed. Note: Editor warnings are only updated when the node tree changes, configuration changes don't trigger an update. You may need to reload the scene after fixing a warning. Notice the RollbackSynchronizer added as a sibling to the RewindableStateMachine, and having its state property configured. Implementing states States are where the custom gameplay logic can be implemented. Each state must be an extension of the RewindableState class, and added as a child to the RewindableStateMachine. States react to the game world using the following callbacks: tick(delta, tick, is_fresh) is called for every rollback tick. enter(previous_state, tick) is called when entering the state. exit(next_state, tick) is called when exiting the state. can_enter(previous_state) is called before entering the state. The state is only entered if this method returns true. You can override any of these callbacks to implement your custom behaviors. For example, the snippet below implements an idle state, that transitions to other states based on movement inputs: extends RewindableState @export var input: PlayerInputStateMachine func tick(delta, tick, is_fresh): if input.movement != Vector3.ZERO: state_machine.transition(&\"Move\") elif input.jump: state_machine.transition(&\"Jump\") Transitions are based on node names , i.e. calling transition(&\"Move\") will transition to a state node called Move . States must be added as children under a RewindableStateMachine to work. Caveats RewindableStateMachine runs in the rollback tick loop , which means that all the Rollback Caveats apply. In addition, rollback ticks are only ran for nodes that have known inputs for the given tick, and need to be simulated - either on the server to determine the new state, or on the client to predict. In practice, ticks are usually only ran on the host owning state and the client owning inputs. The rest of the peers use the state broadcast by the host. This means that transition callbacks are not always ran. This is by design and expected ( see #327 ). As a best practice, in the enter() , exit() callbacks and the on_state_changed signal, only change game state - i.e. properties that are configured as state in RollbackSynchronizer . To update visuals - e.g. change animation, spawn effects, etc. -, use the on_display_state_changed signal to react to state transitions.","title":"RewindableStateMachine"},{"location":"netfox.extras/guides/rewindable-state-machine/#rewindablestatemachine","text":"Rollback-aware state machine implementation. State machines are often used in games to implement different behaviors. However, most implementations are not prepared for rollbacks. This class provides an extensible implementation that can be used alongside a RollbackSynchronizer . For a full example, see multiplayer-state-machine .","title":"RewindableStateMachine"},{"location":"netfox.extras/guides/rewindable-state-machine/#creating-a-state-machine","text":"The first step is to add the RewindableStateMachine to your scene. It also requires a RollbackSynchronizer that manages its state property. Unless these conditions are satisfied, an editor warning will be displayed. Note: Editor warnings are only updated when the node tree changes, configuration changes don't trigger an update. You may need to reload the scene after fixing a warning. Notice the RollbackSynchronizer added as a sibling to the RewindableStateMachine, and having its state property configured.","title":"Creating a state machine"},{"location":"netfox.extras/guides/rewindable-state-machine/#implementing-states","text":"States are where the custom gameplay logic can be implemented. Each state must be an extension of the RewindableState class, and added as a child to the RewindableStateMachine. States react to the game world using the following callbacks: tick(delta, tick, is_fresh) is called for every rollback tick. enter(previous_state, tick) is called when entering the state. exit(next_state, tick) is called when exiting the state. can_enter(previous_state) is called before entering the state. The state is only entered if this method returns true. You can override any of these callbacks to implement your custom behaviors. For example, the snippet below implements an idle state, that transitions to other states based on movement inputs: extends RewindableState @export var input: PlayerInputStateMachine func tick(delta, tick, is_fresh): if input.movement != Vector3.ZERO: state_machine.transition(&\"Move\") elif input.jump: state_machine.transition(&\"Jump\") Transitions are based on node names , i.e. calling transition(&\"Move\") will transition to a state node called Move . States must be added as children under a RewindableStateMachine to work.","title":"Implementing states"},{"location":"netfox.extras/guides/rewindable-state-machine/#caveats","text":"RewindableStateMachine runs in the rollback tick loop , which means that all the Rollback Caveats apply. In addition, rollback ticks are only ran for nodes that have known inputs for the given tick, and need to be simulated - either on the server to determine the new state, or on the client to predict. In practice, ticks are usually only ran on the host owning state and the client owning inputs. The rest of the peers use the state broadcast by the host. This means that transition callbacks are not always ran. This is by design and expected ( see #327 ). As a best practice, in the enter() , exit() callbacks and the on_state_changed signal, only change game state - i.e. properties that are configured as state in RollbackSynchronizer . To update visuals - e.g. change animation, spawn effects, etc. -, use the on_display_state_changed signal to react to state transitions.","title":"Caveats"},{"location":"netfox.extras/guides/window-tiler/","text":"WindowTiler A developer convenience feature that automatically tiles the launched windows when working from the editor. Limitations Borderless mode on Linux Setting window position and size works inconsistently under Linux at the time of writing. Your mileage may vary based on your desktop environment and distribution. In case the windows don't tile properly with Borderless enabled, disabling it is a fallback. Window decorations At the time of writing, there is no known and consistent way to compensate for window decoration size and offset. In practice, this means that windows may slightly overlap. Configuration Auto Tile Windows Enables auto tiling from editor launches. Screen Which screen number to move and tile the windows to. Borderless Enable borderless mode to make the most out of the screen real estate.","title":"WindowTiler"},{"location":"netfox.extras/guides/window-tiler/#windowtiler","text":"A developer convenience feature that automatically tiles the launched windows when working from the editor.","title":"WindowTiler"},{"location":"netfox.extras/guides/window-tiler/#limitations","text":"","title":"Limitations"},{"location":"netfox.extras/guides/window-tiler/#borderless-mode-on-linux","text":"Setting window position and size works inconsistently under Linux at the time of writing. Your mileage may vary based on your desktop environment and distribution. In case the windows don't tile properly with Borderless enabled, disabling it is a fallback.","title":"Borderless mode on Linux"},{"location":"netfox.extras/guides/window-tiler/#window-decorations","text":"At the time of writing, there is no known and consistent way to compensate for window decoration size and offset. In practice, this means that windows may slightly overlap.","title":"Window decorations"},{"location":"netfox.extras/guides/window-tiler/#configuration","text":"Auto Tile Windows Enables auto tiling from editor launches. Screen Which screen number to move and tile the windows to. Borderless Enable borderless mode to make the most out of the screen real estate.","title":"Configuration"},{"location":"netfox.noray/guides/noray/","text":"Noray Singleton providing noray integration. noray is a backend application that orchestrates connection between players. To do this, players send a connection request to noray , and in turn noray sends the players' external addresses to eachother. It is then up to the players to conduct a handshake process. If the handshake fails, players can request a relay from noray . In these cases, noray will receive data from one player and forward it to the other, acting as a middle man. Identifiers noray identifies players with two different IDs: OpenID and PrivateID. OpenID is public, and can be shared with other players. This ID is used to identify hosts when connecting to games. PrivateID is only sent to the player it identifies and should never be shared. Acts similar to a password, and is used to authorize commands. Relays and NAT Punchthrough noray provides two methods of connecting players. NAT Punchthrough relies on the NAT table. Players must continuously send data to eachother until either two-way communication is established, or a timeout is reached. For certain router setups, NAT punchthrough does not work. See: NAT Punch-through for Multiplayer Games For relays , noray allocates a specific port to a given player. When noray receives data on this port, it will forward it as-is to the player. As long as noray is accessible over the internet, relays should work reliably no matter the router setup. Registering with noray To start using noray , connect to a noray server, request IDs by registering, and then register the remote address: var host = \"some.noray.host\" var port = 8890 var err = OK # Connect to noray err = await Noray.connect_to_host(host, port) if err != OK: return err # Failed to connect # Register host Noray.register_host() await Noray.on_pid # Register remote address # This is where noray will direct traffic err = await Noray.register_remote() if err != OK: return err # Failed to register By calling Noray.register_host() , a request is sent to noray . Once a response is received, both the on_pid and on_oid signals are fired, for receiving the PrivateID and OpenID respectively. The remote address must be registered so that noray knows where to direct other players wanting to connect. This process also sets Noray.local_port , which is where traffic can be received through noray . Starting a host To host a game, start listening on noray 's local port: var peer = ENetMultiplayerPeer.new() var err = peer.create_server(Noray.local_port) if err != OK: return false # Failed to listen on port The rest is handled by noray . Starting a client To connect to a game, send a request to noray with the host's OpenID. var oid = \"abcd1234\" # Connect using NAT punchthrough Noray.connect_nat(oid) # Or connect using relay Noray.connect_relay(oid) Once the request is sent, noray will send a message to both the client and the host players to connect to each other. The actual connection is done by handling signals. Note that noray provides no functionality to share OpenIDs. For development, you can display the OpenID in a textbox, letting players copy it and share over their preferred messaging app. Handling signals When a connect message is received, the appropriate signal is fired. on_connect_nat is fired to connect with NAT punchthrough. on_connect_relay is fired to connect to a relay. In both cases, a public address is passed to the signal handler, in the form of an address string and a port. Handlers must conduct a handshake ( e.g. with PacketHandshake ) and connect if successful. Client example: func _ready(): Noray.on_connect_nat.connect(_handle_connect) Noray.on_connect_relay.connect(_handle_connect) func _handle_connect(address: String, port: int) -> Error: # Do a handshake var udp = PacketPeerUDP.new() udp.bind(Noray.local_port) udp.set_dest_address(address, port) var err = await PacketHandshake.over_packet_peer(udp) udp.close() if err != OK: return err # Connect to host var peer = ENetMultiplayerPeer.new() err = peer.create_client(address, port, 0, 0, 0, Noray.local_port) if err != OK: return err return OK Note: Make sure to always specifiy the local port for the client - this is the only port noray recognizes, and failing to specify it will result in broken connectivity. Host example: func _ready(): Noray.on_connect_nat.connect(_handle_connect) Noray.on_connect_relay.connect(_handle_connect) func _handle_connect(address: String, port: int) -> Error: var peer = get_tree().get_multiplayer().multiplayer_peer as ENetMultiplayerPeer var err = await PacketHandshake.over_enet(peer.host, address, port) if err != OK: return err return OK Note: The host handshake is a bit different, as it can't receive manual packets, only send them. So it assumes that the target is always responsive, and just blasts them with a bunch of packets. If the target is indeed responsive, it can connect. If not, nothing happens, as expected.","title":"Noray"},{"location":"netfox.noray/guides/noray/#noray","text":"Singleton providing noray integration. noray is a backend application that orchestrates connection between players. To do this, players send a connection request to noray , and in turn noray sends the players' external addresses to eachother. It is then up to the players to conduct a handshake process. If the handshake fails, players can request a relay from noray . In these cases, noray will receive data from one player and forward it to the other, acting as a middle man.","title":"Noray"},{"location":"netfox.noray/guides/noray/#identifiers","text":"noray identifies players with two different IDs: OpenID and PrivateID. OpenID is public, and can be shared with other players. This ID is used to identify hosts when connecting to games. PrivateID is only sent to the player it identifies and should never be shared. Acts similar to a password, and is used to authorize commands.","title":"Identifiers"},{"location":"netfox.noray/guides/noray/#relays-and-nat-punchthrough","text":"noray provides two methods of connecting players. NAT Punchthrough relies on the NAT table. Players must continuously send data to eachother until either two-way communication is established, or a timeout is reached. For certain router setups, NAT punchthrough does not work. See: NAT Punch-through for Multiplayer Games For relays , noray allocates a specific port to a given player. When noray receives data on this port, it will forward it as-is to the player. As long as noray is accessible over the internet, relays should work reliably no matter the router setup.","title":"Relays and NAT Punchthrough"},{"location":"netfox.noray/guides/noray/#registering-with-noray","text":"To start using noray , connect to a noray server, request IDs by registering, and then register the remote address: var host = \"some.noray.host\" var port = 8890 var err = OK # Connect to noray err = await Noray.connect_to_host(host, port) if err != OK: return err # Failed to connect # Register host Noray.register_host() await Noray.on_pid # Register remote address # This is where noray will direct traffic err = await Noray.register_remote() if err != OK: return err # Failed to register By calling Noray.register_host() , a request is sent to noray . Once a response is received, both the on_pid and on_oid signals are fired, for receiving the PrivateID and OpenID respectively. The remote address must be registered so that noray knows where to direct other players wanting to connect. This process also sets Noray.local_port , which is where traffic can be received through noray .","title":"Registering with noray"},{"location":"netfox.noray/guides/noray/#starting-a-host","text":"To host a game, start listening on noray 's local port: var peer = ENetMultiplayerPeer.new() var err = peer.create_server(Noray.local_port) if err != OK: return false # Failed to listen on port The rest is handled by noray .","title":"Starting a host"},{"location":"netfox.noray/guides/noray/#starting-a-client","text":"To connect to a game, send a request to noray with the host's OpenID. var oid = \"abcd1234\" # Connect using NAT punchthrough Noray.connect_nat(oid) # Or connect using relay Noray.connect_relay(oid) Once the request is sent, noray will send a message to both the client and the host players to connect to each other. The actual connection is done by handling signals. Note that noray provides no functionality to share OpenIDs. For development, you can display the OpenID in a textbox, letting players copy it and share over their preferred messaging app.","title":"Starting a client"},{"location":"netfox.noray/guides/noray/#handling-signals","text":"When a connect message is received, the appropriate signal is fired. on_connect_nat is fired to connect with NAT punchthrough. on_connect_relay is fired to connect to a relay. In both cases, a public address is passed to the signal handler, in the form of an address string and a port. Handlers must conduct a handshake ( e.g. with PacketHandshake ) and connect if successful. Client example: func _ready(): Noray.on_connect_nat.connect(_handle_connect) Noray.on_connect_relay.connect(_handle_connect) func _handle_connect(address: String, port: int) -> Error: # Do a handshake var udp = PacketPeerUDP.new() udp.bind(Noray.local_port) udp.set_dest_address(address, port) var err = await PacketHandshake.over_packet_peer(udp) udp.close() if err != OK: return err # Connect to host var peer = ENetMultiplayerPeer.new() err = peer.create_client(address, port, 0, 0, 0, Noray.local_port) if err != OK: return err return OK Note: Make sure to always specifiy the local port for the client - this is the only port noray recognizes, and failing to specify it will result in broken connectivity. Host example: func _ready(): Noray.on_connect_nat.connect(_handle_connect) Noray.on_connect_relay.connect(_handle_connect) func _handle_connect(address: String, port: int) -> Error: var peer = get_tree().get_multiplayer().multiplayer_peer as ENetMultiplayerPeer var err = await PacketHandshake.over_enet(peer.host, address, port) if err != OK: return err return OK Note: The host handshake is a bit different, as it can't receive manual packets, only send them. So it assumes that the target is always responsive, and just blasts them with a bunch of packets. If the target is indeed responsive, it can connect. If not, nothing happens, as expected.","title":"Handling signals"},{"location":"netfox.noray/guides/packet-handshake/","text":"PacketHandshake Singleton implementing handshake over UDP. The point of the handshake itself is to confirm two-way connection between two parties - i.e. both parties can receive message from the other and receive acknowledgement from the other that their messages have arrived. This is an important step before establishing connection for actual game play, as this lets both the client's and server's routers ( if any ) know that traffic is expected and should be let through. NAT punchthrough Most players are behind a router. Routers are directly connected to the internet, and protect machines behind them from unwanted traffic. When routers receive packets from an unknown source, those packets are rejected and don't reach the player's device. When data was sent to that address first, routers see traffic as a reply and allow incoming data. To take an example, if a random PC starts sending traffic your way, the router will reject it. If you send data to the host behind godotengine.org, your router will allow incoming traffic from it. Otherwise, you wouldn't be able to open the website in your browser, as the incoming HTTP response would be rejected. This can be used to our advantage. If both players start sending traffic towards eachother, eventually the routers will assume it's a response to some request and allow the traffic. This is a very simplified description of how routers work. NAT punchthrough does not always work. For further reading, see Network address translation . Handshake process To confirm two-way connectivity, a string is sent back and forth, encoding the player's knowledge about the connection: The Read flag is set once we have received data from the other player. The Write flag is set once we send data to the other player. Since data is always sent, this flag is always set. The Duplex flag is set when we have received data from the other player knowing that they have also received data from us. This means that data flows both ways. The handshake process is successful when both players have the Duplex flag set and both players know that the other player has the Duplex flag set. Each flag is encoded as its specific character or a hyphen. The encoded string is prepended with a dollar sign. For example: $rw- means that we have sent and received data from the other player $rwx means that the read , write , and duplex flags are all set Here's the handshake process illustrated: Handshake over PacketPeer To run the handshake over raw UDP, call PacketHandshake.over_packet_peer . The specified PacketPeer will be used to send data until two-way connectivity is confirmed or the timeout is reached. Between every packet sent, it takes a short pause. Note that the PacketPeer must already be configured with a target address. Handshake over ENetConnection If the game is already running, the handshake must be done over the already active connection. For this case, use PacketHandshake.over_enet . This connection can't be used to receive custom packets, only to send them. So the target address will be spammed with traffic confirming two-way connectivity until timeout. Handshake will always be considered successful. If the connectivity exists, players will simply connect. Otherwise, connectivity will fail as expected, regardless of the handshake results.","title":"PacketHandshake"},{"location":"netfox.noray/guides/packet-handshake/#packethandshake","text":"Singleton implementing handshake over UDP. The point of the handshake itself is to confirm two-way connection between two parties - i.e. both parties can receive message from the other and receive acknowledgement from the other that their messages have arrived. This is an important step before establishing connection for actual game play, as this lets both the client's and server's routers ( if any ) know that traffic is expected and should be let through.","title":"PacketHandshake"},{"location":"netfox.noray/guides/packet-handshake/#nat-punchthrough","text":"Most players are behind a router. Routers are directly connected to the internet, and protect machines behind them from unwanted traffic. When routers receive packets from an unknown source, those packets are rejected and don't reach the player's device. When data was sent to that address first, routers see traffic as a reply and allow incoming data. To take an example, if a random PC starts sending traffic your way, the router will reject it. If you send data to the host behind godotengine.org, your router will allow incoming traffic from it. Otherwise, you wouldn't be able to open the website in your browser, as the incoming HTTP response would be rejected. This can be used to our advantage. If both players start sending traffic towards eachother, eventually the routers will assume it's a response to some request and allow the traffic. This is a very simplified description of how routers work. NAT punchthrough does not always work. For further reading, see Network address translation .","title":"NAT punchthrough"},{"location":"netfox.noray/guides/packet-handshake/#handshake-process","text":"To confirm two-way connectivity, a string is sent back and forth, encoding the player's knowledge about the connection: The Read flag is set once we have received data from the other player. The Write flag is set once we send data to the other player. Since data is always sent, this flag is always set. The Duplex flag is set when we have received data from the other player knowing that they have also received data from us. This means that data flows both ways. The handshake process is successful when both players have the Duplex flag set and both players know that the other player has the Duplex flag set. Each flag is encoded as its specific character or a hyphen. The encoded string is prepended with a dollar sign. For example: $rw- means that we have sent and received data from the other player $rwx means that the read , write , and duplex flags are all set Here's the handshake process illustrated:","title":"Handshake process"},{"location":"netfox.noray/guides/packet-handshake/#handshake-over-packetpeer","text":"To run the handshake over raw UDP, call PacketHandshake.over_packet_peer . The specified PacketPeer will be used to send data until two-way connectivity is confirmed or the timeout is reached. Between every packet sent, it takes a short pause. Note that the PacketPeer must already be configured with a target address.","title":"Handshake over PacketPeer"},{"location":"netfox.noray/guides/packet-handshake/#handshake-over-enetconnection","text":"If the game is already running, the handshake must be done over the already active connection. For this case, use PacketHandshake.over_enet . This connection can't be used to receive custom packets, only to send them. So the target address will be spammed with traffic confirming two-way connectivity until timeout. Handshake will always be considered successful. If the connectivity exists, players will simply connect. Otherwise, connectivity will fail as expected, regardless of the handshake results.","title":"Handshake over ENetConnection"}]}