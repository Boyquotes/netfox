<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://foxssake.github.io/netfox/v0.15.9/tutorials/rollback/" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Rollback - netfox</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../css/version-select.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Rollback";
        var mkdocs_page_input_path = "tutorials/rollback.md";
        var mkdocs_page_url = "/netfox/v0.15.9/tutorials/rollback/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> netfox
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Tutorials</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../ticking-in-sync/">Ticking in Sync</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Rollback</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#tldr">tl;dr</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#the-challenge">The Challenge</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#setting-up-rollback">Setting up rollback</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#gathering-input">Gathering input</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#writing-rollback-aware-simulation">Writing rollback-aware simulation</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#smoothing-motion">Smoothing motion</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#node-setup">Node setup</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#caveats">Caveats</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#characterbodies-and-velocity">CharacterBodies and velocity</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#characterbodies-and-floors">CharacterBodies and floors</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#physics-updates">Physics updates</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Guides</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../guides/network-time/">NetworkTime</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../guides/network-time-synchronizer/">NetworkTimeSynchronizer</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../guides/network-events/">NetworkEvents</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../guides/interpolators/">Interpolators</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../guides/property-paths/">Property paths</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../guides/network-rollback/">NetworkRollback</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Nodes</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../nodes/tick-interpolator/">TickInterpolator</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">netfox</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Tutorials</li>
      <li class="breadcrumb-item active">Rollback</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="rollback">Rollback</h1>
<p>You may have noted earlier that documentation talks about <em>rollback</em>, <em>lag
compensation</em> and even <em>CSP</em> ( client-side prediction and server reconciliation
) multiple times, almost interchangeably.</p>
<p>The docs refer to CSP as rollback. They are a way to do lag compensation.</p>
<h2 id="tldr">tl;dr</h2>
<ul>
<li>Setup a <code>RollbackSynchronizer</code> for sync and a <code>TickInterpolator</code> for smooth
  motion</li>
<li>Create an input node with your own script, inherit <code>BaseNetInput</code> from
  netfox.extras</li>
<li>Put your player logic in the <code>_rollback_tick(tick, delta, is_fresh)</code> method</li>
<li>See Forest Brawl examples:<ul>
<li><a href="https://github.com/foxssake/netfox/blob/main/examples/forest-brawl/scripts/brawler-input.gd">brawler-input.gd</a></li>
<li><a href="https://github.com/foxssake/netfox/blob/main/examples/forest-brawl/scripts/brawler-controller.gd">brawler-controller.gd</a></li>
</ul>
</li>
</ul>
<h2 id="the-challenge">The Challenge</h2>
<p>You don't want your players to cheat. Nobody does. However, you publish your
game and give it to the player. The player's environment is entirely out of the
developer's control, players do whatever they want with it, which gives lots of
room to cheat.</p>
<p>For example, there were some applications that scanned a game's entire memory
and watched it for changes. When the player lost some health, the memory
address of the change was detected, and always set to its original value. This
way, whenever the player received damage in the game, this external application
would reset the player's health.</p>
<p>Since this was something people did in the early '00s, one could imagine that
cheating is still something very doable. All of this is to show that as game
developer, you do not want to trust the clients.</p>
<p>So what can you control? The server. This is how server-authoritative games
were born.</p>
<p>The idea is to simulate the whole game on the server and make it the source of
truth. Clients submit their inputs ( i.e. "I'm running north" ) on each tick,
the server updates the game state, and broadcasts the changes. All is swell.</p>
<p>Unless you consider latency. Let's say the latency is 50ms. Which means that
when the player presses a key to provide input, it will take 50ms for that
input to travel to the server, then some time passes as the server processes
all the inputs, then another 50ms for the new state to arrive.</p>
<p>Basically, it took slightly more than a tenth of a second before anything
happened on the player's screen after pressing a key. Aside from niche cases,
this is not very enjoyable. Not even mentioning that 50ms is a pretty decent
latency - in worse cases, it can be even 100-200ms, it can vary, it can jitter,
packets can be lost, all depending on network conditions.</p>
<p>This is where Client-Side Prediction and Server Reconciliation come in to save
the day. Instead of waiting for the server to return to us with a new game
state, we simulate <em>some</em> of the updates locally as well - for example, player
movement. We move the player along according to the input, then take a note of
the result. Once the server returns with the updated game state, clients can
adjust their local simulations accordingly. </p>
<p>Most of the time, the clients' simulation will match that of the server, so
nothing happens. In case the client simulated something differently ( or was
cheating ), reconciliation kicks in and the difference will be corrected.</p>
<p>And thus, we can have our cake and eat it too - we consider the server as the
single source of truth, but also get responsive controls.</p>
<p>Further reading:</p>
<ul>
<li><a href="https://www.gabrielgambetta.com/client-server-game-architecture.html">Client-Server Game Architecture</a></li>
<li><a href="https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html">Client-Side Prediction and Server Reconciliation</a></li>
</ul>
<h2 id="setting-up-rollback">Setting up rollback</h2>
<p>Similar to Godot's <code>MultiplayerSynchronizer</code>, netfox's node for rollback is
<code>RollbackSynchronizer</code>. And much in the same vein, you can configure it with
state and input properties:</p>
<p><img alt="Rollback config" src="../../assets/rollback-config.png" /></p>
<p>To use it, simply add it to your scene. The best practice is to add it directly
under the object you want it to synchronize.</p>
<p><em>Root</em> is the node you want to synchronize. Typically this is the
synchronizer's parent, as per best practice. Not setting this field will result
in error.</p>
<p><em>State properties</em> describe the synchronized object's current state - whatever
properties are listed here will be synchronized over the network. The
screenshot provides a good example for movement - we want to synchronize the
player's transform and velocity, so we can replicate motion across
clients.</p>
<p><em>Input properties</em> point to properties describing the player's inputs. Inputs
are also replicated across the network, but are used to update the simulation.
The server uses these inputs to update its local state and broadcast it, which
the clients will accept as truth.</p>
<h2 id="gathering-input">Gathering input</h2>
<p>To gather the player's input, all you need to do is set the configured <em>input
properties</em> from your code - the rest will be handled by
<code>RollbackSynchronizer</code>.</p>
<p>The other important part is <em>when</em> to set these properties. On each frame,
netfox checks the time elapsed since the last network tick, and runs as many
ticks as necessary. So, it may happen that during a single <code>_process</code> run, no
network ticks are run, a single tick is run, or even multiple.</p>
<p>When running multiple ticks in a single <code>_process</code>, it makes no sense to poll
your input devices for each tick, as they most probably won't change. Instead,
you can set your properties at the start of the network tick loop:</p>
<pre><code class="language-gdscript">class_name PlayerInput

var movement: Vector3 = Vector3.ZERO

func _ready():
  NetworkTime.before_tick_loop.connect(_gather)

func _gather():
  if not is_multiplayer_authority():
    return

  movement = Vector3(
    Input.get_axis(&quot;move_west&quot;, &quot;move_east&quot;),
    Input.get_action_strength(&quot;move_jump&quot;),
    Input.get_axis(&quot;move_north&quot;, &quot;move_south&quot;)
  )
</code></pre>
<p>Notice that we only set the movement variable if we have the authority over the
input node. This is important, otherwise everyone would be controlling
everyone's avatar.</p>
<p>While it is useful to know the details, <em>netfox.extras</em> provides a convenience
class called <code>BaseNetInput</code> that you can extend to do pretty much the same
thing, but slightly easier:</p>
<pre><code class="language-gdscript">extends BaseNetInput
class_name PlayerInput

var movement: Vector3 = Vector3.ZERO

func _gather():
  movement = Vector3(
    Input.get_axis(&quot;move_west&quot;, &quot;move_east&quot;),
    0,
    Input.get_axis(&quot;move_north&quot;, &quot;move_south&quot;)
  )
</code></pre>
<p>The two snippets above accomplish the same behaviour.</p>
<h2 id="writing-rollback-aware-simulation">Writing rollback-aware simulation</h2>
<p>Writing your rollback-aware simulation is very similar to your regular
simulation - the most significant change is where you put your behaviour.</p>
<p>Instead of <code>_process</code> or <code>_physics_process</code>, you implement <code>_rollback_tick</code> to
simulate a network tick. This method is automatically discovered by the
<code>RollbackSynchronizer</code> and called as necessary. Before calling it, the
synchronizer will restore the state of the given tick, so your simulation code
doesn't need to bother with that either. You can think of it as travelling back
in time and re-running a frame.</p>
<p>Since inputs may arrive at different times for the same tick, we may need to
re-simulate the same tick multiple times as the game goes on. To make it easier
to discern which point of time is being simulated, the <code>_rollback_tick</code> method
receives multiple parameters:</p>
<pre><code class="language-gdscript">func _rollback_tick(delta: float, tick: int, is_fresh: bool)
</code></pre>
<p><em>delta</em> is the same as for <code>_process</code> or <code>_physics_process</code>, the amount of time
in seconds elapsed since the last tick.</p>
<p><em>tick</em> is the current time of the simulation, in ticks. This can and will be
different from <code>NetworkTime.tick</code>.</p>
<p><em>is_fresh</em> is a flag that indicates whether or not this is the first time we're
simulating this given tick. This is useful for triggering particle systems or
sound effects, since you don't want to spawn an explosion every time we
resimulate that same frame.</p>
<p>So to put it all together into a simple example:</p>
<pre><code class="language-gdscript">extends CharacterBody3D

@export var speed = 4.0
@export var input: PlayerInput

func _rollback_tick(delta, tick, is_fresh):
  velocity = input.movement.normalized() * speed
  velocity *= NetworkTime.physics_factor

  move_and_slide()
</code></pre>
<p>Note that the velocity is pre-multiplied before executing the move, which
counteracts one of the caveats discussed below.</p>
<h2 id="smoothing-motion">Smoothing motion</h2>
<p>Using the above as-is would lead to responsive gameplay with rollback, but
certainly wouldn't feel like it - motion would be choppy. This happens because
the player's position would only be updated during network ticks, which are set
to 30 ticks per second by default.</p>
<p>Instead of setting this to 60 or 120 and blasting through your bandwidth, you
can use the <code>TickInterpolator</code> node, which will smoothly interpolate <em>state
properties</em> between ticks.</p>
<p>To do so, simply add the node and configure it similarly to
<code>RollbackSynchronizer</code>:</p>
<p><img alt="TickInterpolator configuration" src="../../assets/tick-interpolator-config.png" /></p>
<p><em>Root</em> is the starting point for interpolation, property paths will be
considered relative to this node.</p>
<p><em>Properties</em> are the state properties to be interpolated between ticks. Note
that these are only used for visuals, so you'd rarely need to interpolate
velocity for example.</p>
<h2 id="node-setup">Node setup</h2>
<p>To tie all of the above together, you need your rollback-aware simulation on
your character, under which you add your input node and configure a
<code>RollbackSynchronizer</code> and a <code>TickInterpolator</code>. For any other properties that
don't need rollback-aware synchronization, you can use Godot's built-in
<code>MultiplayerSynchronizer</code>.</p>
<p>For reference, take a look at the following node setup from Forest Brawl:</p>
<p><img alt="Rollback node setup" src="../../assets/rollback-nodes.png" /></p>
<h2 id="caveats">Caveats</h2>
<h3 id="characterbodies-and-velocity">CharacterBodies and velocity</h3>
<p>Calling <code>move_and_slide()</code> will move the object based on its <code>velocity</code>
property. However, this velocity, taken as m/s, will assume the current
<code>_process</code> or <code>_physics_process</code> delta, depending on whether we're in a physics
frame or a regular one.</p>
<p>This becomes an issue when it's called from a network tick or rollback tick, as
Godot's built-in methods are not aware that they're being called in netfox's
tick loop.</p>
<p>To work around this issue, you can use <code>NetworkTime.physics_factor</code> as a
multiplier on your velocities. This property will always yield a multiplier
that can be used to convert the velocity specified in the network tick's
context to the current frame context.</p>
<p>If you don't want to lose your original velocity ( e.g. because it accumulates
acceleration over time ), you can just divide by the same property after using
any built-in method. For example:</p>
<pre><code class="language-gdscript"># Apply movement
velocity *= NetworkTime.physics_factor
move_and_slide()
velocity /= NetworkTime.physics_factor
</code></pre>
<h3 id="characterbodies-and-floors">CharacterBodies and floors</h3>
<p>CharacterBodies have multiple utilities to see if they're on the floor,
touching a wall, etc. However, these are only updated after a
<code>move_and_slide()</code> call.</p>
<p>This means that between two <code>move_and_slide</code>'s, rollback may kick in and place
the node in a completely different position, while the utilities would still
provide info based on the previous state.</p>
<p>You can do this by simply doing a zero-move before checking if the node is e.g.
on the floor:</p>
<pre><code class="language-gdscript">extends CharacterBody3D

func _rollback_tick(delta, tick, is_fresh):
    # Add the gravity.
    _force_update_is_on_floor()
    if not is_on_floor():
        velocity.y -= gravity * delta

  # ...

func _force_update_is_on_floor():
    var old_velocity = velocity
    velocity = Vector3.ZERO
    move_and_slide()
    velocity = old_velocity
</code></pre>
<h3 id="physics-updates">Physics updates</h3>
<p>Godot's physics system is updated only during <code>_physics_process</code>, while
rollback updates the game state multiple times during a single frame.</p>
<p>Unfortunately, Godot does not support manually updating or stepping the physics
system, at least at the time of writing. This means that:</p>
<ul>
<li>Rollback and physics-based games don't work at the moment</li>
<li>Collision detection can work, but with workarounds</li>
</ul>
<p>If there's a way to force an update for your given node type, it should work.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../ticking-in-sync/" class="btn btn-neutral float-left" title="Ticking in Sync"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../../guides/network-time/" class="btn btn-neutral float-right" title="NetworkTime">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../ticking-in-sync/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../../guides/network-time/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
      <script src="../../js/version-select.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
