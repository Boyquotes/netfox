{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"netfox A set of addons for responsive online games with the Godot engine . Features \u23f2\ufe0f Consistent timing across multiple machines \ud83d\udda5\ufe0f Supports client-server architecture \ud83e\uddc8 Smooth motion with easy-to-use interpolation \ud83d\udca8 Lag compensation with Client-side Prediction and Server-side Reconciliation \ud83d\udedc Bullet-proof connectivity with noray integration Getting started Netfox consists of three addons: netfox The core package, implements timing, rollback and other multiplayer features Start here netfox.noray Implements noray integration to establish connection between players Useful for online games netfox.extras Provides high-level, game-specific, convenience features built on top of netfox, like base classes for input management or weapons Check for reusable components for your game Download the addons needed from the latest release ( TBA ), or grab the source and copy the addons folder to your project. With netfox added to your project, you're ready to take advantage of its features, as outlined in the tutorials. About this documentation These pages assume that you are familiar with both Godot, its multiplayer capabilities, and building multiplayer games in general. Missing any of these might make your reading experience more difficult than preferred. Some links to get you up to speed: Godot Engine docs Godot Engine High-level multiplayer Networking for Physics Programmers About the tutorials Tutorials contain a challenge section - this part is to describe the actual difficulty the feature solves. In case you are experienced with building multiplayer games, feel free to skip these sections.","title":"Home"},{"location":"#netfox","text":"A set of addons for responsive online games with the Godot engine .","title":"netfox"},{"location":"#features","text":"\u23f2\ufe0f Consistent timing across multiple machines \ud83d\udda5\ufe0f Supports client-server architecture \ud83e\uddc8 Smooth motion with easy-to-use interpolation \ud83d\udca8 Lag compensation with Client-side Prediction and Server-side Reconciliation \ud83d\udedc Bullet-proof connectivity with noray integration","title":"Features"},{"location":"#getting-started","text":"Netfox consists of three addons: netfox The core package, implements timing, rollback and other multiplayer features Start here netfox.noray Implements noray integration to establish connection between players Useful for online games netfox.extras Provides high-level, game-specific, convenience features built on top of netfox, like base classes for input management or weapons Check for reusable components for your game Download the addons needed from the latest release ( TBA ), or grab the source and copy the addons folder to your project. With netfox added to your project, you're ready to take advantage of its features, as outlined in the tutorials.","title":"Getting started"},{"location":"#about-this-documentation","text":"These pages assume that you are familiar with both Godot, its multiplayer capabilities, and building multiplayer games in general. Missing any of these might make your reading experience more difficult than preferred. Some links to get you up to speed: Godot Engine docs Godot Engine High-level multiplayer Networking for Physics Programmers","title":"About this documentation"},{"location":"#about-the-tutorials","text":"Tutorials contain a challenge section - this part is to describe the actual difficulty the feature solves. In case you are experienced with building multiplayer games, feel free to skip these sections.","title":"About the tutorials"},{"location":"guides/interpolators/","text":"Interpolators Tracks interpolators for various data types. Provided as an autoload. To smooth out motion between network ticks, TickInterpolator interpolates nodes' state properties between the current and the previous tick. The type of data to be interpolated is not known in advance, and can be any built-in or even custom type configured by the developer. Interpolators provides methods to register interpolators for any data type, and even provides some for built-in data types. Interpolating values Interpolators can be used to interpolate between any two values, as long as they hold the same data type: extends Node3D @export var target_node @export var approach_time = 0.5 func _process(delta): # Approach target node, if it exists if target_node: var from_xform = global_transform var to_xform = target_node.global_transform var factor = delta / approach_time global_transform = Interpolators.interpolate(from_xform, to_xform, factor) Note that in this case, Interpolators will try to look up the appropriate interpolator based on the provided values. If no interpolator is found, a fallback is used, that simply returns the value closer to factor - i.e. the starting value if factor is less than 0.5 and the target value otherwise. Caching interpolators To avoid having to look up the right interpolator every frame, you can cache it: extends Node3D @export target_node @export approach_time = 0.5 var interpolator func _ready(): interpolator = Interpolators.find_for(global_transform) func _process(delta): # Approach target node, if it exists if target_node: var from_xform = global_transform var to_xform = target_node.global_transform var factor = delta / approach_time global_transform = interpolator.call(from_xform, to_xform, factor) Custom interpolators Interpolators supports interpolators for custom data types, and even overriding built-in interpolators. Both can be done by registering an interpolator: Interpolators.register( func(a): return a is float, # Condition func(a, b, f): return lerpf(a, b, f * f) # Interpolation ) The above registers a custom interpolator by specifying a condition function and an interpolation function. Since it applies to an already supported type, it overrides the built-in interpolator. During lookup, Interpolators calls the condition function of each interpolator and returns the one whose condition function returns true. If multiple interpolators are applicable, Interpolators returns the last registered one. The interpolation function receives the starting value a , the target value b and the interpolation factor f . Built-in interpolators The following types are supported by default: float Vector2 Vector3 Transform2D Transform3D","title":"Interpolators"},{"location":"guides/interpolators/#interpolators","text":"Tracks interpolators for various data types. Provided as an autoload. To smooth out motion between network ticks, TickInterpolator interpolates nodes' state properties between the current and the previous tick. The type of data to be interpolated is not known in advance, and can be any built-in or even custom type configured by the developer. Interpolators provides methods to register interpolators for any data type, and even provides some for built-in data types.","title":"Interpolators"},{"location":"guides/interpolators/#interpolating-values","text":"Interpolators can be used to interpolate between any two values, as long as they hold the same data type: extends Node3D @export var target_node @export var approach_time = 0.5 func _process(delta): # Approach target node, if it exists if target_node: var from_xform = global_transform var to_xform = target_node.global_transform var factor = delta / approach_time global_transform = Interpolators.interpolate(from_xform, to_xform, factor) Note that in this case, Interpolators will try to look up the appropriate interpolator based on the provided values. If no interpolator is found, a fallback is used, that simply returns the value closer to factor - i.e. the starting value if factor is less than 0.5 and the target value otherwise.","title":"Interpolating values"},{"location":"guides/interpolators/#caching-interpolators","text":"To avoid having to look up the right interpolator every frame, you can cache it: extends Node3D @export target_node @export approach_time = 0.5 var interpolator func _ready(): interpolator = Interpolators.find_for(global_transform) func _process(delta): # Approach target node, if it exists if target_node: var from_xform = global_transform var to_xform = target_node.global_transform var factor = delta / approach_time global_transform = interpolator.call(from_xform, to_xform, factor)","title":"Caching interpolators"},{"location":"guides/interpolators/#custom-interpolators","text":"Interpolators supports interpolators for custom data types, and even overriding built-in interpolators. Both can be done by registering an interpolator: Interpolators.register( func(a): return a is float, # Condition func(a, b, f): return lerpf(a, b, f * f) # Interpolation ) The above registers a custom interpolator by specifying a condition function and an interpolation function. Since it applies to an already supported type, it overrides the built-in interpolator. During lookup, Interpolators calls the condition function of each interpolator and returns the one whose condition function returns true. If multiple interpolators are applicable, Interpolators returns the last registered one. The interpolation function receives the starting value a , the target value b and the interpolation factor f .","title":"Custom interpolators"},{"location":"guides/interpolators/#built-in-interpolators","text":"The following types are supported by default: float Vector2 Vector3 Transform2D Transform3D","title":"Built-in interpolators"},{"location":"guides/network-events/","text":"NetworkEvents Provides convenience signals for multiplayer games. Included as an autoload. Keeps track of the root multiplayer instance and fires signals when it changes. Using NetworkEvents ' signals are safe even when the multiplayer instance changes, as the signals are updated upon instance change. Provides missing signals for server start and server stop events. NetworkTime When enabled, NetworkEvents will start NetworkTime when it detects that a server or a client is started. It will stop NetworkTime , when it detects that the currently running server or client is stopped. Settings Settings are found in the Project Settings, under Netfox > Events: Enabled toggles network events. When disabled, NetworkEvents will not emit any events or track the multiplayer instance. This may slightly improve performance, as it completely stops Godot from processing the NetworkEvents node.","title":"NetworkEvents"},{"location":"guides/network-events/#networkevents","text":"Provides convenience signals for multiplayer games. Included as an autoload. Keeps track of the root multiplayer instance and fires signals when it changes. Using NetworkEvents ' signals are safe even when the multiplayer instance changes, as the signals are updated upon instance change. Provides missing signals for server start and server stop events.","title":"NetworkEvents"},{"location":"guides/network-events/#networktime","text":"When enabled, NetworkEvents will start NetworkTime when it detects that a server or a client is started. It will stop NetworkTime , when it detects that the currently running server or client is stopped.","title":"NetworkTime"},{"location":"guides/network-events/#settings","text":"Settings are found in the Project Settings, under Netfox > Events: Enabled toggles network events. When disabled, NetworkEvents will not emit any events or track the multiplayer instance. This may slightly improve performance, as it completely stops Godot from processing the NetworkEvents node.","title":"Settings"},{"location":"guides/network-rollback/","text":"NetworkRollback Orchestrates the network rollback loop. Provided as an autoload. Due to latency, the server may receive inputs from clients from multiple ticks ago. Whenever this happens, the server rewinds its time and resimulates the whole game from the time of the new input. The resimulated ticks are then sent to clients to update their state. Also due to latency, clients may receive a state from the server that is several ticks old. Clients rewind their simulation to the time of the latest received state and resimulate from there. On both clients and servers, simulated states are recorded for reuse later. Further reading: Client-Side Prediction and Server Reconciliation Note that most of the time you do not need to use this class - the RollbackSynchronizer node helps with writing rollback-aware behaviour. Network rollback loop NetworkRollback runs the network rollback loop after every network tick, but before the after tick signal is fired. The following is the network rollback loop in isolation: Signal handlers must implement the right steps for rollback to work. During before_loop , all rollback-aware nodes must submit where to start the resimulation, by calling NetworkRollback.notify_resimulation_start . Resimulation will begin from the earliest tick submitted. In each on_prepare_tick(tick) handler, nodes must rewind their state to the specified tick. If a state is not available for the given tick, use the latest tick that is earlier than the given tick. Nodes may also register themselves as being simulated by calling NetworkRollback.notify_simulated . This is not used by NetworkRollback itself, but can be used by other nodes to check which nodes are simulated in the current rollback tick. For the on_process_tick(tick) signal, nodes must advance their simulation by a single tick. In on_record_tick(tick) , nodes must record their state for the given tick. Note that since the simulation was advanced by one tick in the previous signal, the tick parameter is incremented here. The after_loop signal notifies its subscribers that the resimulation is done. This can be used to change to the state that is appropriate for display. The network rollback loop is part of the network tick loop as follows: Conditional simulation During rollback, NetworkRollback loops over the full range of ticks to resimulate. Some nodes may not need to be resimulated for the current tick, e.g. because they don't have input for the current tick. NetworkRollback can be used to track nodes that will be simulated in the current rollback tick. Register nodes that will be simulated by calling NetworkRollback.notify_simulated . To check if a node has been registered, call NetworkRollback.is_simulated . Rollback-awareness RollbackSynchronizer considers nodes rollback-aware that implement the _rollback_tick method. Rollback-aware nodes are nodes that can participate in the rollback process, i.e. they can resimulate earlier ticks. To check if a node is rollback-aware, call NetworkRollback.is_rollback_aware . To actually run a rollback tick on them, call NetworkRollback.process_rollback . These methods are called by RollbackSynchronizer under the hood. Settings Enabled toggles network rollback. No signals are fired when disabled. History limit is the maximum number of recorded ticks to keep. Larger values enable further rewinds and thus larger latencies, but consume more memory for each node that is recorded. Display offset specifies the age of the tick to display. By displaying an older state instead of the latest one, games can mask adjustments if a state update is received from the server. The drawback is that the game will have some latency built-in, as it reacts to player inputs with some delay. Setting to zero will always display the latest game state.","title":"NetworkRollback"},{"location":"guides/network-rollback/#networkrollback","text":"Orchestrates the network rollback loop. Provided as an autoload. Due to latency, the server may receive inputs from clients from multiple ticks ago. Whenever this happens, the server rewinds its time and resimulates the whole game from the time of the new input. The resimulated ticks are then sent to clients to update their state. Also due to latency, clients may receive a state from the server that is several ticks old. Clients rewind their simulation to the time of the latest received state and resimulate from there. On both clients and servers, simulated states are recorded for reuse later. Further reading: Client-Side Prediction and Server Reconciliation Note that most of the time you do not need to use this class - the RollbackSynchronizer node helps with writing rollback-aware behaviour.","title":"NetworkRollback"},{"location":"guides/network-rollback/#network-rollback-loop","text":"NetworkRollback runs the network rollback loop after every network tick, but before the after tick signal is fired. The following is the network rollback loop in isolation: Signal handlers must implement the right steps for rollback to work. During before_loop , all rollback-aware nodes must submit where to start the resimulation, by calling NetworkRollback.notify_resimulation_start . Resimulation will begin from the earliest tick submitted. In each on_prepare_tick(tick) handler, nodes must rewind their state to the specified tick. If a state is not available for the given tick, use the latest tick that is earlier than the given tick. Nodes may also register themselves as being simulated by calling NetworkRollback.notify_simulated . This is not used by NetworkRollback itself, but can be used by other nodes to check which nodes are simulated in the current rollback tick. For the on_process_tick(tick) signal, nodes must advance their simulation by a single tick. In on_record_tick(tick) , nodes must record their state for the given tick. Note that since the simulation was advanced by one tick in the previous signal, the tick parameter is incremented here. The after_loop signal notifies its subscribers that the resimulation is done. This can be used to change to the state that is appropriate for display. The network rollback loop is part of the network tick loop as follows:","title":"Network rollback loop"},{"location":"guides/network-rollback/#conditional-simulation","text":"During rollback, NetworkRollback loops over the full range of ticks to resimulate. Some nodes may not need to be resimulated for the current tick, e.g. because they don't have input for the current tick. NetworkRollback can be used to track nodes that will be simulated in the current rollback tick. Register nodes that will be simulated by calling NetworkRollback.notify_simulated . To check if a node has been registered, call NetworkRollback.is_simulated .","title":"Conditional simulation"},{"location":"guides/network-rollback/#rollback-awareness","text":"RollbackSynchronizer considers nodes rollback-aware that implement the _rollback_tick method. Rollback-aware nodes are nodes that can participate in the rollback process, i.e. they can resimulate earlier ticks. To check if a node is rollback-aware, call NetworkRollback.is_rollback_aware . To actually run a rollback tick on them, call NetworkRollback.process_rollback . These methods are called by RollbackSynchronizer under the hood.","title":"Rollback-awareness"},{"location":"guides/network-rollback/#settings","text":"Enabled toggles network rollback. No signals are fired when disabled. History limit is the maximum number of recorded ticks to keep. Larger values enable further rewinds and thus larger latencies, but consume more memory for each node that is recorded. Display offset specifies the age of the tick to display. By displaying an older state instead of the latest one, games can mask adjustments if a state update is received from the server. The drawback is that the game will have some latency built-in, as it reacts to player inputs with some delay. Setting to zero will always display the latest game state.","title":"Settings"},{"location":"guides/network-time-synchronizer/","text":"NetworkTimeSynchronizer Synchronizes time towards a target peer. Provided as an autoload. Synchronization is run periodically in a loop. During synchronization, the NetworkTimeSynchronizer measures the roundtrip to the target peer, assumes latency is half of the roundtrip, and adds the latency to the latest time received from the target peer. To estimate the roundtrip time, it sends multiple ping messages to the target peer, measuring how much time it takes to get a response. Measurements that are too far from the average are rejected to filter out latency spikes. Further reading: Time, Tick, Clock Synchronisation Most of the time you shouldn't need to interface with this class directly, instead you can use NetworkTime .","title":"NetworkTimeSynchronizer"},{"location":"guides/network-time-synchronizer/#networktimesynchronizer","text":"Synchronizes time towards a target peer. Provided as an autoload. Synchronization is run periodically in a loop. During synchronization, the NetworkTimeSynchronizer measures the roundtrip to the target peer, assumes latency is half of the roundtrip, and adds the latency to the latest time received from the target peer. To estimate the roundtrip time, it sends multiple ping messages to the target peer, measuring how much time it takes to get a response. Measurements that are too far from the average are rejected to filter out latency spikes. Further reading: Time, Tick, Clock Synchronisation Most of the time you shouldn't need to interface with this class directly, instead you can use NetworkTime .","title":"NetworkTimeSynchronizer"},{"location":"guides/network-time/","text":"NetworkTime Tracks shared network time between players, and provides an event loop for synchronized game updates. Provided as an autoload. A separate timer is provided for network ticks, making the network game update rate independent from rendering or physics frames. Network tick loop NetworkTime provides its own independent event loop by exposing signals. This makes networked game logic independent of current FPS, and makes it run at a consistent rate. Connect handlers to NetworkTime 's signals to implement networked game logic. During each frame, NetworkTime checks how much time has elapsed since the last tick loop. When more time has elapsed than a single tick's duration, the network tick loop will run: The tick loop will run as long as it catches up on ticks to run. Every loop is limited to run at most max_ticks_per_frame ticks to avoid overwhelming the CPU. To tie the network tick loop to Godot's physics process, enable sync_to_physics . This will result in the tick loop running a single tick in every physics update. To move your game logic to the network tick loop, use the on_tick event: extends Node3D @export var speed = 4.0 func _ready(): NetworkTime.on_tick.connect(_tick) func _tick(delta, tick): # Move forward position += basis.z * delta * speed By convention, on_tick handlers are named _tick . Starting and stopping By default, NetworkTime does not run the tick loop at all. This lets you control when the network tick loop, and thus the game starts and stops. To start the tick loop, call the NetworkTime.start() coroutine. On servers, this will start the tick loop and return immediately. On clients, it will first synchronize the time to the server, start the network tick loop, and only then return. Use this when starting the game. Starting the tick loop before starting multiplayer is not supported. To stop the tick loop, call NetworkTime.stop() . This will immediately stop the tick loop and return. Use this when the player leaves a game. To get notified when a client successfully syncs their time and starts the tick loop, use the NetworkTime.after_client_sync(peer_id) signal. This is fired once per client, and only on the server. Time synchronization NetworkTime runs a time synchronization loop on clients, in the background. Synchronizing time makes sure that all players have a shared idea of time and can exchange timing-related data. The synchronization itself is handled by NetworkTimeSynchronizer . NetworkTime provides different kinds of time, each for different use cases. Each time can be accessed as ticks or seconds. Both advance after every network tick. Local time NetworkTime.local_time NetworkTime.local_ticks Marks the current time in reference to the local machine. Starts at zero when the network tick loop starts. Useful for logic that is tied to the tick loop, but is not synchronized over the network. A good example is visual effects. Not suitable for synchronizing data, as the local time is different at each player. Remote time NetworkTime.remote_ticks NetwokrTime.remote_time NetworkTime.remote_rtt Marks the current estimated time of the server. This is a regularly updated estimate. Note that on each update, the remote time may jump forwards or even backwards. The estimate is based on the measured roundtrip time ( remote_rtt ) and the assumption that the latency is exactly half of that. Can be used as a base for comparisons ( e.g. latency ), but not recommended for tying game logic to it. To get notified when a time synchronization happens and the remote time is updated, use the NetworkTime.after_sync signal. Time NetworkTime.time NetworkTime.ticks Marks the current network game time. On start, this time is set to the estimated remote time. The game time is only adjusted if it is too far off from the remote time, making it a good, consistent source of time. Can be used when timing data needs to be shared between players, and for game logic that is synchronized over the network. Settings Settings are found in the Project Settings, under Netfox > Time: Tickrate specifies the number of ticks every second in the network tick loop. Max Ticks Per Frame sets the maximum number of frames to simulate per tick loop. Used to avoid freezing the game under load. Recalibrate Threshold is the largest allowed time discrepancy in seconds. If the difference between the remote time and game time is larger than this setting, the game time will be reset to the remote time. Sync Interval is the resting time between time synchronizations. Note that the synchronization itself may take multiple seconds, so overall there will be more time between two synchronization runs than just the interval. Sync Samples is the number of measurements to take for estimating roundtrip time. Sync Sample Interval is the resting time between roundtrip measurements. Sync to Physics ties the network tick loop to the physics process when enabled.","title":"NetworkTime"},{"location":"guides/network-time/#networktime","text":"Tracks shared network time between players, and provides an event loop for synchronized game updates. Provided as an autoload. A separate timer is provided for network ticks, making the network game update rate independent from rendering or physics frames.","title":"NetworkTime"},{"location":"guides/network-time/#network-tick-loop","text":"NetworkTime provides its own independent event loop by exposing signals. This makes networked game logic independent of current FPS, and makes it run at a consistent rate. Connect handlers to NetworkTime 's signals to implement networked game logic. During each frame, NetworkTime checks how much time has elapsed since the last tick loop. When more time has elapsed than a single tick's duration, the network tick loop will run: The tick loop will run as long as it catches up on ticks to run. Every loop is limited to run at most max_ticks_per_frame ticks to avoid overwhelming the CPU. To tie the network tick loop to Godot's physics process, enable sync_to_physics . This will result in the tick loop running a single tick in every physics update. To move your game logic to the network tick loop, use the on_tick event: extends Node3D @export var speed = 4.0 func _ready(): NetworkTime.on_tick.connect(_tick) func _tick(delta, tick): # Move forward position += basis.z * delta * speed By convention, on_tick handlers are named _tick .","title":"Network tick loop"},{"location":"guides/network-time/#starting-and-stopping","text":"By default, NetworkTime does not run the tick loop at all. This lets you control when the network tick loop, and thus the game starts and stops. To start the tick loop, call the NetworkTime.start() coroutine. On servers, this will start the tick loop and return immediately. On clients, it will first synchronize the time to the server, start the network tick loop, and only then return. Use this when starting the game. Starting the tick loop before starting multiplayer is not supported. To stop the tick loop, call NetworkTime.stop() . This will immediately stop the tick loop and return. Use this when the player leaves a game. To get notified when a client successfully syncs their time and starts the tick loop, use the NetworkTime.after_client_sync(peer_id) signal. This is fired once per client, and only on the server.","title":"Starting and stopping"},{"location":"guides/network-time/#time-synchronization","text":"NetworkTime runs a time synchronization loop on clients, in the background. Synchronizing time makes sure that all players have a shared idea of time and can exchange timing-related data. The synchronization itself is handled by NetworkTimeSynchronizer . NetworkTime provides different kinds of time, each for different use cases. Each time can be accessed as ticks or seconds. Both advance after every network tick.","title":"Time synchronization"},{"location":"guides/network-time/#local-time","text":"NetworkTime.local_time NetworkTime.local_ticks Marks the current time in reference to the local machine. Starts at zero when the network tick loop starts. Useful for logic that is tied to the tick loop, but is not synchronized over the network. A good example is visual effects. Not suitable for synchronizing data, as the local time is different at each player.","title":"Local time"},{"location":"guides/network-time/#remote-time","text":"NetworkTime.remote_ticks NetwokrTime.remote_time NetworkTime.remote_rtt Marks the current estimated time of the server. This is a regularly updated estimate. Note that on each update, the remote time may jump forwards or even backwards. The estimate is based on the measured roundtrip time ( remote_rtt ) and the assumption that the latency is exactly half of that. Can be used as a base for comparisons ( e.g. latency ), but not recommended for tying game logic to it. To get notified when a time synchronization happens and the remote time is updated, use the NetworkTime.after_sync signal.","title":"Remote time"},{"location":"guides/network-time/#time","text":"NetworkTime.time NetworkTime.ticks Marks the current network game time. On start, this time is set to the estimated remote time. The game time is only adjusted if it is too far off from the remote time, making it a good, consistent source of time. Can be used when timing data needs to be shared between players, and for game logic that is synchronized over the network.","title":"Time"},{"location":"guides/network-time/#settings","text":"Settings are found in the Project Settings, under Netfox > Time: Tickrate specifies the number of ticks every second in the network tick loop. Max Ticks Per Frame sets the maximum number of frames to simulate per tick loop. Used to avoid freezing the game under load. Recalibrate Threshold is the largest allowed time discrepancy in seconds. If the difference between the remote time and game time is larger than this setting, the game time will be reset to the remote time. Sync Interval is the resting time between time synchronizations. Note that the synchronization itself may take multiple seconds, so overall there will be more time between two synchronization runs than just the interval. Sync Samples is the number of measurements to take for estimating roundtrip time. Sync Sample Interval is the resting time between roundtrip measurements. Sync to Physics ties the network tick loop to the physics process when enabled.","title":"Settings"},{"location":"guides/property-paths/","text":"Property paths Multiple nodes have properties as their configurations. These are specified as property paths , which have a specific syntax. These nodes have a Root property. During path resolution, this Root node is taken as base for relative paths. Syntax Property paths are specified as follows: <node-path>:<property-name> Node path can be empty if it refers to a property on the root node. If specified, node path will be interpreted relative to the root node. Any valid NodePath will work as expected. With Brawler as root: :position refers to the Brawler's position Input:aim refers to the Input's aim","title":"Property paths"},{"location":"guides/property-paths/#property-paths","text":"Multiple nodes have properties as their configurations. These are specified as property paths , which have a specific syntax. These nodes have a Root property. During path resolution, this Root node is taken as base for relative paths.","title":"Property paths"},{"location":"guides/property-paths/#syntax","text":"Property paths are specified as follows: <node-path>:<property-name> Node path can be empty if it refers to a property on the root node. If specified, node path will be interpreted relative to the root node. Any valid NodePath will work as expected. With Brawler as root: :position refers to the Brawler's position Input:aim refers to the Input's aim","title":"Syntax"},{"location":"nodes/tick-interpolator/","text":"TickInterpolator Interpolates between network ticks to smooth out motion. Uses Interpolators under the hood to support various data types. Configuring interpolation To use TickInterpolator , add it as a child to the target node, specify the root node, and configure which properties to interpolate: Root specifies the root node for resolving Properties . Best practice dictates to add TickInterpolator under its target, so Root will most often be the TickInterpolator 's parent node. Properties specify which properties to interpolate. See Property paths on how to specify these values. Record First State will make TickInterpolator take a snapshot when the Node is instantiated. This snapshot will be used for interpolation, instead of waiting for the next network tick. Useful for objects which start moving instantly upon entering the scene tree, like projectiles. Enable Recording toggles automatic state recording. When enabled, TickInterpolator will take a new snapshot after each network tick loop and interpolate towards that. Disabling this will require you to manually call push_state() whenever the properties are updated. Sudden changes When a node makes a sudden change, like teleporting from one place to another, interpolation may not be desired. Call teleport() in these cases to avoid interpolation and just jump to the current state. Interpolation will resume after the current state. Example: func _tick(tick, delta): # Respawn after a while if _tick == respawn_tick: # Jump to spawn point, without interpolation position = spawn_position $TickInterpolator.teleport() Changing configuration TickInterpolator has to do some setup work whenever the interpolated properties change, e.g. when a new property needs to be interpolated. By default, this work is done upon instantiation. If you need to change interpolated properties during runtime, make sure to call process_settings() , otherwise TickInterpolator won't apply the changes.","title":"TickInterpolator"},{"location":"nodes/tick-interpolator/#tickinterpolator","text":"Interpolates between network ticks to smooth out motion. Uses Interpolators under the hood to support various data types.","title":"TickInterpolator"},{"location":"nodes/tick-interpolator/#configuring-interpolation","text":"To use TickInterpolator , add it as a child to the target node, specify the root node, and configure which properties to interpolate: Root specifies the root node for resolving Properties . Best practice dictates to add TickInterpolator under its target, so Root will most often be the TickInterpolator 's parent node. Properties specify which properties to interpolate. See Property paths on how to specify these values. Record First State will make TickInterpolator take a snapshot when the Node is instantiated. This snapshot will be used for interpolation, instead of waiting for the next network tick. Useful for objects which start moving instantly upon entering the scene tree, like projectiles. Enable Recording toggles automatic state recording. When enabled, TickInterpolator will take a new snapshot after each network tick loop and interpolate towards that. Disabling this will require you to manually call push_state() whenever the properties are updated.","title":"Configuring interpolation"},{"location":"nodes/tick-interpolator/#sudden-changes","text":"When a node makes a sudden change, like teleporting from one place to another, interpolation may not be desired. Call teleport() in these cases to avoid interpolation and just jump to the current state. Interpolation will resume after the current state. Example: func _tick(tick, delta): # Respawn after a while if _tick == respawn_tick: # Jump to spawn point, without interpolation position = spawn_position $TickInterpolator.teleport()","title":"Sudden changes"},{"location":"nodes/tick-interpolator/#changing-configuration","text":"TickInterpolator has to do some setup work whenever the interpolated properties change, e.g. when a new property needs to be interpolated. By default, this work is done upon instantiation. If you need to change interpolated properties during runtime, make sure to call process_settings() , otherwise TickInterpolator won't apply the changes.","title":"Changing configuration"},{"location":"tutorials/rollback/","text":"Rollback You may have noted earlier that documentation talks about rollback , lag compensation and even CSP ( client-side prediction and server reconciliation ) multiple times, almost interchangeably. The docs refer to CSP as rollback. They are a way to do lag compensation. tl;dr Setup a RollbackSynchronizer for sync and a TickInterpolator for smooth motion Create an input node with your own script, inherit BaseNetInput from netfox.extras Put your player logic in the _rollback_tick(tick, delta, is_fresh) method See Forest Brawl examples: brawler-input.gd brawler-controller.gd The Challenge You don't want your players to cheat. Nobody does. However, you publish your game and give it to the player. The player's environment is entirely out of the developer's control, players do whatever they want with it, which gives lots of room to cheat. For example, there were some applications that scanned a game's entire memory and watched it for changes. When the player lost some health, the memory address of the change was detected, and always set to its original value. This way, whenever the player received damage in the game, this external application would reset the player's health. Since this was something people did in the early '00s, one could imagine that cheating is still something very doable. All of this is to show that as game developer, you do not want to trust the clients. So what can you control? The server. This is how server-authoritative games were born. The idea is to simulate the whole game on the server and make it the source of truth. Clients submit their inputs ( i.e. \"I'm running north\" ) on each tick, the server updates the game state, and broadcasts the changes. All is swell. Unless you consider latency. Let's say the latency is 50ms. Which means that when the player presses a key to provide input, it will take 50ms for that input to travel to the server, then some time passes as the server processes all the inputs, then another 50ms for the new state to arrive. Basically, it took slightly more than a tenth of a second before anything happened on the player's screen after pressing a key. Aside from niche cases, this is not very enjoyable. Not even mentioning that 50ms is a pretty decent latency - in worse cases, it can be even 100-200ms, it can vary, it can jitter, packets can be lost, all depending on network conditions. This is where Client-Side Prediction and Server Reconciliation come in to save the day. Instead of waiting for the server to return to us with a new game state, we simulate some of the updates locally as well - for example, player movement. We move the player along according to the input, then take a note of the result. Once the server returns with the updated game state, clients can adjust their local simulations accordingly. Most of the time, the clients' simulation will match that of the server, so nothing happens. In case the client simulated something differently ( or was cheating ), reconciliation kicks in and the difference will be corrected. And thus, we can have our cake and eat it too - we consider the server as the single source of truth, but also get responsive controls. Further reading: Client-Server Game Architecture Client-Side Prediction and Server Reconciliation Setting up rollback Similar to Godot's MultiplayerSynchronizer , netfox's node for rollback is RollbackSynchronizer . And much in the same vein, you can configure it with state and input properties: To use it, simply add it to your scene. The best practice is to add it directly under the object you want it to synchronize. Root is the node you want to synchronize. Typically this is the synchronizer's parent, as per best practice. Not setting this field will result in error. State properties describe the synchronized object's current state - whatever properties are listed here will be synchronized over the network. The screenshot provides a good example for movement - we want to synchronize the player's transform and velocity, so we can replicate motion across clients. Input properties point to properties describing the player's inputs. Inputs are also replicated across the network, but are used to update the simulation. The server uses these inputs to update its local state and broadcast it, which the clients will accept as truth. Gathering input To gather the player's input, all you need to do is set the configured input properties from your code - the rest will be handled by RollbackSynchronizer . The other important part is when to set these properties. On each frame, netfox checks the time elapsed since the last network tick, and runs as many ticks as necessary. So, it may happen that during a single _process run, no network ticks are run, a single tick is run, or even multiple. When running multiple ticks in a single _process , it makes no sense to poll your input devices for each tick, as they most probably won't change. Instead, you can set your properties at the start of the network tick loop: class_name PlayerInput var movement: Vector3 = Vector3.ZERO func _ready(): NetworkTime.before_tick_loop.connect(_gather) func _gather(): if not is_multiplayer_authority(): return movement = Vector3( Input.get_axis(\"move_west\", \"move_east\"), Input.get_action_strength(\"move_jump\"), Input.get_axis(\"move_north\", \"move_south\") ) Notice that we only set the movement variable if we have the authority over the input node. This is important, otherwise everyone would be controlling everyone's avatar. While it is useful to know the details, netfox.extras provides a convenience class called BaseNetInput that you can extend to do pretty much the same thing, but slightly easier: extends BaseNetInput class_name PlayerInput var movement: Vector3 = Vector3.ZERO func _gather(): movement = Vector3( Input.get_axis(\"move_west\", \"move_east\"), 0, Input.get_axis(\"move_north\", \"move_south\") ) The two snippets above accomplish the same behaviour. Writing rollback-aware simulation Writing your rollback-aware simulation is very similar to your regular simulation - the most significant change is where you put your behaviour. Instead of _process or _physics_process , you implement _rollback_tick to simulate a network tick. This method is automatically discovered by the RollbackSynchronizer and called as necessary. Before calling it, the synchronizer will restore the state of the given tick, so your simulation code doesn't need to bother with that either. You can think of it as travelling back in time and re-running a frame. Since inputs may arrive at different times for the same tick, we may need to re-simulate the same tick multiple times as the game goes on. To make it easier to discern which point of time is being simulated, the _rollback_tick method receives multiple parameters: func _rollback_tick(delta: float, tick: int, is_fresh: bool) delta is the same as for _process or _physics_process , the amount of time in seconds elapsed since the last tick. tick is the current time of the simulation, in ticks. This can and will be different from NetworkTime.tick . is_fresh is a flag that indicates whether or not this is the first time we're simulating this given tick. This is useful for triggering particle systems or sound effects, since you don't want to spawn an explosion every time we resimulate that same frame. So to put it all together into a simple example: extends CharacterBody3D @export var speed = 4.0 @export var input: PlayerInput func _rollback_tick(delta, tick, is_fresh): velocity = input.movement.normalized() * speed velocity *= NetworkTime.physics_factor move_and_slide() Note that the velocity is pre-multiplied before executing the move, which counteracts one of the caveats discussed below. Smoothing motion Using the above as-is would lead to responsive gameplay with rollback, but certainly wouldn't feel like it - motion would be choppy. This happens because the player's position would only be updated during network ticks, which are set to 30 ticks per second by default. Instead of setting this to 60 or 120 and blasting through your bandwidth, you can use the TickInterpolator node, which will smoothly interpolate state properties between ticks. To do so, simply add the node and configure it similarly to RollbackSynchronizer : Root is the starting point for interpolation, property paths will be considered relative to this node. Properties are the state properties to be interpolated between ticks. Note that these are only used for visuals, so you'd rarely need to interpolate velocity for example. Node setup To tie all of the above together, you need your rollback-aware simulation on your character, under which you add your input node and configure a RollbackSynchronizer and a TickInterpolator . For any other properties that don't need rollback-aware synchronization, you can use Godot's built-in MultiplayerSynchronizer . For reference, take a look at the following node setup from Forest Brawl: Caveats CharacterBodies and velocity Calling move_and_slide() will move the object based on its velocity property. However, this velocity, taken as m/s, will assume the current _process or _physics_process delta, depending on whether we're in a physics frame or a regular one. This becomes an issue when it's called from a network tick or rollback tick, as Godot's built-in methods are not aware that they're being called in netfox's tick loop. To work around this issue, you can use NetworkTime.physics_factor as a multiplier on your velocities. This property will always yield a multiplier that can be used to convert the velocity specified in the network tick's context to the current frame context. If you don't want to lose your original velocity ( e.g. because it accumulates acceleration over time ), you can just divide by the same property after using any built-in method. For example: # Apply movement velocity *= NetworkTime.physics_factor move_and_slide() velocity /= NetworkTime.physics_factor CharacterBodies and floors CharacterBodies have multiple utilities to see if they're on the floor, touching a wall, etc. However, these are only updated after a move_and_slide() call. This means that between two move_and_slide 's, rollback may kick in and place the node in a completely different position, while the utilities would still provide info based on the previous state. You can do this by simply doing a zero-move before checking if the node is e.g. on the floor: extends CharacterBody3D func _rollback_tick(delta, tick, is_fresh): # Add the gravity. _force_update_is_on_floor() if not is_on_floor(): velocity.y -= gravity * delta # ... func _force_update_is_on_floor(): var old_velocity = velocity velocity = Vector3.ZERO move_and_slide() velocity = old_velocity Physics updates Godot's physics system is updated only during _physics_process , while rollback updates the game state multiple times during a single frame. Unfortunately, Godot does not support manually updating or stepping the physics system, at least at the time of writing. This means that: Rollback and physics-based games don't work at the moment Collision detection can work, but with workarounds If there's a way to force an update for your given node type, it should work.","title":"Rollback"},{"location":"tutorials/rollback/#rollback","text":"You may have noted earlier that documentation talks about rollback , lag compensation and even CSP ( client-side prediction and server reconciliation ) multiple times, almost interchangeably. The docs refer to CSP as rollback. They are a way to do lag compensation.","title":"Rollback"},{"location":"tutorials/rollback/#tldr","text":"Setup a RollbackSynchronizer for sync and a TickInterpolator for smooth motion Create an input node with your own script, inherit BaseNetInput from netfox.extras Put your player logic in the _rollback_tick(tick, delta, is_fresh) method See Forest Brawl examples: brawler-input.gd brawler-controller.gd","title":"tl;dr"},{"location":"tutorials/rollback/#the-challenge","text":"You don't want your players to cheat. Nobody does. However, you publish your game and give it to the player. The player's environment is entirely out of the developer's control, players do whatever they want with it, which gives lots of room to cheat. For example, there were some applications that scanned a game's entire memory and watched it for changes. When the player lost some health, the memory address of the change was detected, and always set to its original value. This way, whenever the player received damage in the game, this external application would reset the player's health. Since this was something people did in the early '00s, one could imagine that cheating is still something very doable. All of this is to show that as game developer, you do not want to trust the clients. So what can you control? The server. This is how server-authoritative games were born. The idea is to simulate the whole game on the server and make it the source of truth. Clients submit their inputs ( i.e. \"I'm running north\" ) on each tick, the server updates the game state, and broadcasts the changes. All is swell. Unless you consider latency. Let's say the latency is 50ms. Which means that when the player presses a key to provide input, it will take 50ms for that input to travel to the server, then some time passes as the server processes all the inputs, then another 50ms for the new state to arrive. Basically, it took slightly more than a tenth of a second before anything happened on the player's screen after pressing a key. Aside from niche cases, this is not very enjoyable. Not even mentioning that 50ms is a pretty decent latency - in worse cases, it can be even 100-200ms, it can vary, it can jitter, packets can be lost, all depending on network conditions. This is where Client-Side Prediction and Server Reconciliation come in to save the day. Instead of waiting for the server to return to us with a new game state, we simulate some of the updates locally as well - for example, player movement. We move the player along according to the input, then take a note of the result. Once the server returns with the updated game state, clients can adjust their local simulations accordingly. Most of the time, the clients' simulation will match that of the server, so nothing happens. In case the client simulated something differently ( or was cheating ), reconciliation kicks in and the difference will be corrected. And thus, we can have our cake and eat it too - we consider the server as the single source of truth, but also get responsive controls. Further reading: Client-Server Game Architecture Client-Side Prediction and Server Reconciliation","title":"The Challenge"},{"location":"tutorials/rollback/#setting-up-rollback","text":"Similar to Godot's MultiplayerSynchronizer , netfox's node for rollback is RollbackSynchronizer . And much in the same vein, you can configure it with state and input properties: To use it, simply add it to your scene. The best practice is to add it directly under the object you want it to synchronize. Root is the node you want to synchronize. Typically this is the synchronizer's parent, as per best practice. Not setting this field will result in error. State properties describe the synchronized object's current state - whatever properties are listed here will be synchronized over the network. The screenshot provides a good example for movement - we want to synchronize the player's transform and velocity, so we can replicate motion across clients. Input properties point to properties describing the player's inputs. Inputs are also replicated across the network, but are used to update the simulation. The server uses these inputs to update its local state and broadcast it, which the clients will accept as truth.","title":"Setting up rollback"},{"location":"tutorials/rollback/#gathering-input","text":"To gather the player's input, all you need to do is set the configured input properties from your code - the rest will be handled by RollbackSynchronizer . The other important part is when to set these properties. On each frame, netfox checks the time elapsed since the last network tick, and runs as many ticks as necessary. So, it may happen that during a single _process run, no network ticks are run, a single tick is run, or even multiple. When running multiple ticks in a single _process , it makes no sense to poll your input devices for each tick, as they most probably won't change. Instead, you can set your properties at the start of the network tick loop: class_name PlayerInput var movement: Vector3 = Vector3.ZERO func _ready(): NetworkTime.before_tick_loop.connect(_gather) func _gather(): if not is_multiplayer_authority(): return movement = Vector3( Input.get_axis(\"move_west\", \"move_east\"), Input.get_action_strength(\"move_jump\"), Input.get_axis(\"move_north\", \"move_south\") ) Notice that we only set the movement variable if we have the authority over the input node. This is important, otherwise everyone would be controlling everyone's avatar. While it is useful to know the details, netfox.extras provides a convenience class called BaseNetInput that you can extend to do pretty much the same thing, but slightly easier: extends BaseNetInput class_name PlayerInput var movement: Vector3 = Vector3.ZERO func _gather(): movement = Vector3( Input.get_axis(\"move_west\", \"move_east\"), 0, Input.get_axis(\"move_north\", \"move_south\") ) The two snippets above accomplish the same behaviour.","title":"Gathering input"},{"location":"tutorials/rollback/#writing-rollback-aware-simulation","text":"Writing your rollback-aware simulation is very similar to your regular simulation - the most significant change is where you put your behaviour. Instead of _process or _physics_process , you implement _rollback_tick to simulate a network tick. This method is automatically discovered by the RollbackSynchronizer and called as necessary. Before calling it, the synchronizer will restore the state of the given tick, so your simulation code doesn't need to bother with that either. You can think of it as travelling back in time and re-running a frame. Since inputs may arrive at different times for the same tick, we may need to re-simulate the same tick multiple times as the game goes on. To make it easier to discern which point of time is being simulated, the _rollback_tick method receives multiple parameters: func _rollback_tick(delta: float, tick: int, is_fresh: bool) delta is the same as for _process or _physics_process , the amount of time in seconds elapsed since the last tick. tick is the current time of the simulation, in ticks. This can and will be different from NetworkTime.tick . is_fresh is a flag that indicates whether or not this is the first time we're simulating this given tick. This is useful for triggering particle systems or sound effects, since you don't want to spawn an explosion every time we resimulate that same frame. So to put it all together into a simple example: extends CharacterBody3D @export var speed = 4.0 @export var input: PlayerInput func _rollback_tick(delta, tick, is_fresh): velocity = input.movement.normalized() * speed velocity *= NetworkTime.physics_factor move_and_slide() Note that the velocity is pre-multiplied before executing the move, which counteracts one of the caveats discussed below.","title":"Writing rollback-aware simulation"},{"location":"tutorials/rollback/#smoothing-motion","text":"Using the above as-is would lead to responsive gameplay with rollback, but certainly wouldn't feel like it - motion would be choppy. This happens because the player's position would only be updated during network ticks, which are set to 30 ticks per second by default. Instead of setting this to 60 or 120 and blasting through your bandwidth, you can use the TickInterpolator node, which will smoothly interpolate state properties between ticks. To do so, simply add the node and configure it similarly to RollbackSynchronizer : Root is the starting point for interpolation, property paths will be considered relative to this node. Properties are the state properties to be interpolated between ticks. Note that these are only used for visuals, so you'd rarely need to interpolate velocity for example.","title":"Smoothing motion"},{"location":"tutorials/rollback/#node-setup","text":"To tie all of the above together, you need your rollback-aware simulation on your character, under which you add your input node and configure a RollbackSynchronizer and a TickInterpolator . For any other properties that don't need rollback-aware synchronization, you can use Godot's built-in MultiplayerSynchronizer . For reference, take a look at the following node setup from Forest Brawl:","title":"Node setup"},{"location":"tutorials/rollback/#caveats","text":"","title":"Caveats"},{"location":"tutorials/rollback/#characterbodies-and-velocity","text":"Calling move_and_slide() will move the object based on its velocity property. However, this velocity, taken as m/s, will assume the current _process or _physics_process delta, depending on whether we're in a physics frame or a regular one. This becomes an issue when it's called from a network tick or rollback tick, as Godot's built-in methods are not aware that they're being called in netfox's tick loop. To work around this issue, you can use NetworkTime.physics_factor as a multiplier on your velocities. This property will always yield a multiplier that can be used to convert the velocity specified in the network tick's context to the current frame context. If you don't want to lose your original velocity ( e.g. because it accumulates acceleration over time ), you can just divide by the same property after using any built-in method. For example: # Apply movement velocity *= NetworkTime.physics_factor move_and_slide() velocity /= NetworkTime.physics_factor","title":"CharacterBodies and velocity"},{"location":"tutorials/rollback/#characterbodies-and-floors","text":"CharacterBodies have multiple utilities to see if they're on the floor, touching a wall, etc. However, these are only updated after a move_and_slide() call. This means that between two move_and_slide 's, rollback may kick in and place the node in a completely different position, while the utilities would still provide info based on the previous state. You can do this by simply doing a zero-move before checking if the node is e.g. on the floor: extends CharacterBody3D func _rollback_tick(delta, tick, is_fresh): # Add the gravity. _force_update_is_on_floor() if not is_on_floor(): velocity.y -= gravity * delta # ... func _force_update_is_on_floor(): var old_velocity = velocity velocity = Vector3.ZERO move_and_slide() velocity = old_velocity","title":"CharacterBodies and floors"},{"location":"tutorials/rollback/#physics-updates","text":"Godot's physics system is updated only during _physics_process , while rollback updates the game state multiple times during a single frame. Unfortunately, Godot does not support manually updating or stepping the physics system, at least at the time of writing. This means that: Rollback and physics-based games don't work at the moment Collision detection can work, but with workarounds If there's a way to force an update for your given node type, it should work.","title":"Physics updates"},{"location":"tutorials/ticking-in-sync/","text":"Ticking in Sync tl;dr Call NetworkTime.start() when gameplay starts and NetworkTime.stop() when it ends Subscribe to NetworkTime.on_tick signal for your game logic, instead of _process or _physics_process Use NetworkTime.time or NetworkTime.tick for current game time in seconds or ticks respectively For more in-depth explanations, see NetworkTime The challenge Ticks Multiplayer games, similarly to \"regular\" single-player games, are interactive simulations. These consist of a game state ( e.g. the map, the players, the enemies, etc. ), which are affected by the player via input ( e.g. keyboard and mouse ). Based on this input, the game state is updated regularly, many times a second, giving the illusion that things happen continuously, in a fluid manner. We will refer to these updates as ticks . The amount of ticks in a second is called the tickrate . It would sound logical to run games at as high as a tickrate as the PC can handle to make everything smoother, but that can be actually counter-intuitive. Some kinds of simulations can be sensitive to varying tickrates, and often the actual tickrate doesn't even need to be that high. For slower games, you may be able to get away with 30 ticks per second, instead of trying to push through 1200 updates per second over the Atlantic. Note that this tickrate can differ from the game's render rate or frames per second you see on the screen. For rendering, games generally either try to match the display's refresh rate, or just output as many frames as they can. Adding multiplayer to the mix complicates things a lot further, almost irrespective of the architecture used, as handling player data and/or input that can arrive at any moment can be difficult. To simplify things and avoid a lot of edge cases, we can make sure that all players' simulation runs at the same tickrate, so that for example one player won't send twice as many updates as another in the same interval. Having a fixed tickrate also makes it easier to think of each tick as a list of steps we can do to make sure the simulation is consistent across all players, for example: Gather inputs from all players Update player state Broadcast changes Imagine trying to do the same, but trying to account for the fact that one player is running at 60 ticks per second and needs very frequent updates, the other player is doing 30 ticks per second, and we may or may not receive any input at all, or we may receive multiple inputs for the same tick. Times Other times, we need to synchronize data or events that are tied to times. For example, a player picked up a powerup and it will expire at the 27th second of the game. Or player B will respawn at the 38th second. For these cases, it's important to have all clients share a common notion of time - what's the current time? While this does not need to be exact ( and doesn't even need to be ), it is important that this shared notion to be reasonably accurate, and for time to advance at the same rate at every player. NetworkTime NetworkTime is netfox's solution to synchronizing time and tickrate for all participants. It drives the network tick loop, by emitting signals. Subscribing to these guarantees that ticks are done at the same rate for all the participants. While ticks happen at the same time, you may need different notions of time for different use cases. To use NetworkTime, call NetworkTime.start() when your game starts ( either by hosting it or connecting to a server ), and call NetworkTime.stop() once the game is over. Different times Local time This is the simplest one of them all. It is basically the time that has elapsed since NetworkTime is running - it starts at 0 and ticks upwards infinitely. Can be used for things that are updated during network ticks, but don't need to be synchronized across multiple devices, for example visuals. NetworkTime.local_time - The number of seconds elapsed in local time NetworkTime.local_ticks - The number of ticks elapsed in local time Remote time To think in terms of shared time, the time on the host must be known. Due to the laws of physics, we can't know exactly what's the time on the host. We may ask, but it also takes time to send the question and receive the answer, so the received info will be off. In addition, we can't know if the information travels the same speed towards the host as it travels back to us. This latter part is actually impossible to ever know - from our single point of view, it might have taken 0% of the time to send the question, and 100% of the time to receive the answer, and we wouldn't notice anything from it! However, it is possible to estimate the time this roundtrip takes, and then assume that information travels the same speed both ways - thus deduce that latency is half of our estimated roundtrip. And with that, we have an estimate of what's the time on the host. Note that network conditions may change, thus the remote time is regularly updated by the newest estimate. This also means that the remote time may jump forwards or even backwards, as it's updated. Can be used as a base for comparisons ( e.g. latency ), but not recommended for tying game logic to it. NetworkTime.remote_ticks - Estimated time on the host, in ticks NetwokrTime.remote_time - Estimated time on the host, in seconds NetworkTime.remote_rtt - Estimated roundtrip time to host, in seconds Time \"Regular\" time combines the best of both worlds - it is based on an estimate of the host's time, but doesn't jump around. It is synced to the host once, and then only ever updated in case the clocks go extremely out of sync for whatever reason. Use this as your go-to solution, and specifically when you need to share timestamps between clients - for example sending a message saying Player C fired their gun at tick #357. NetworkTime.time - Network time, in seconds NetworkTime.ticks - Network time, in ticks Utilities NetworkTime also provides various methods and properties regarding time: NetworkTime.tickrate NetworkTime.ticktime NetworkTime.tick_factor NetworkTime.ticks_to_seconds(ticks) NetworkTime.seconds_to_ticks(seconds) NetworkTime.ticks_between(from_seconds, to_seconds) NetworkTime.seconds_between(from_tick, to_tick) TODO : Reference docs Project Settings Actual tickrate is controlled by project settings, and cannot be changed at runtime. The settings themselves are under Netfox/Time .","title":"Ticking in Sync"},{"location":"tutorials/ticking-in-sync/#ticking-in-sync","text":"","title":"Ticking in Sync"},{"location":"tutorials/ticking-in-sync/#tldr","text":"Call NetworkTime.start() when gameplay starts and NetworkTime.stop() when it ends Subscribe to NetworkTime.on_tick signal for your game logic, instead of _process or _physics_process Use NetworkTime.time or NetworkTime.tick for current game time in seconds or ticks respectively For more in-depth explanations, see NetworkTime","title":"tl;dr"},{"location":"tutorials/ticking-in-sync/#the-challenge","text":"","title":"The challenge"},{"location":"tutorials/ticking-in-sync/#ticks","text":"Multiplayer games, similarly to \"regular\" single-player games, are interactive simulations. These consist of a game state ( e.g. the map, the players, the enemies, etc. ), which are affected by the player via input ( e.g. keyboard and mouse ). Based on this input, the game state is updated regularly, many times a second, giving the illusion that things happen continuously, in a fluid manner. We will refer to these updates as ticks . The amount of ticks in a second is called the tickrate . It would sound logical to run games at as high as a tickrate as the PC can handle to make everything smoother, but that can be actually counter-intuitive. Some kinds of simulations can be sensitive to varying tickrates, and often the actual tickrate doesn't even need to be that high. For slower games, you may be able to get away with 30 ticks per second, instead of trying to push through 1200 updates per second over the Atlantic. Note that this tickrate can differ from the game's render rate or frames per second you see on the screen. For rendering, games generally either try to match the display's refresh rate, or just output as many frames as they can. Adding multiplayer to the mix complicates things a lot further, almost irrespective of the architecture used, as handling player data and/or input that can arrive at any moment can be difficult. To simplify things and avoid a lot of edge cases, we can make sure that all players' simulation runs at the same tickrate, so that for example one player won't send twice as many updates as another in the same interval. Having a fixed tickrate also makes it easier to think of each tick as a list of steps we can do to make sure the simulation is consistent across all players, for example: Gather inputs from all players Update player state Broadcast changes Imagine trying to do the same, but trying to account for the fact that one player is running at 60 ticks per second and needs very frequent updates, the other player is doing 30 ticks per second, and we may or may not receive any input at all, or we may receive multiple inputs for the same tick.","title":"Ticks"},{"location":"tutorials/ticking-in-sync/#times","text":"Other times, we need to synchronize data or events that are tied to times. For example, a player picked up a powerup and it will expire at the 27th second of the game. Or player B will respawn at the 38th second. For these cases, it's important to have all clients share a common notion of time - what's the current time? While this does not need to be exact ( and doesn't even need to be ), it is important that this shared notion to be reasonably accurate, and for time to advance at the same rate at every player.","title":"Times"},{"location":"tutorials/ticking-in-sync/#networktime","text":"NetworkTime is netfox's solution to synchronizing time and tickrate for all participants. It drives the network tick loop, by emitting signals. Subscribing to these guarantees that ticks are done at the same rate for all the participants. While ticks happen at the same time, you may need different notions of time for different use cases. To use NetworkTime, call NetworkTime.start() when your game starts ( either by hosting it or connecting to a server ), and call NetworkTime.stop() once the game is over.","title":"NetworkTime"},{"location":"tutorials/ticking-in-sync/#different-times","text":"","title":"Different times"},{"location":"tutorials/ticking-in-sync/#local-time","text":"This is the simplest one of them all. It is basically the time that has elapsed since NetworkTime is running - it starts at 0 and ticks upwards infinitely. Can be used for things that are updated during network ticks, but don't need to be synchronized across multiple devices, for example visuals. NetworkTime.local_time - The number of seconds elapsed in local time NetworkTime.local_ticks - The number of ticks elapsed in local time","title":"Local time"},{"location":"tutorials/ticking-in-sync/#remote-time","text":"To think in terms of shared time, the time on the host must be known. Due to the laws of physics, we can't know exactly what's the time on the host. We may ask, but it also takes time to send the question and receive the answer, so the received info will be off. In addition, we can't know if the information travels the same speed towards the host as it travels back to us. This latter part is actually impossible to ever know - from our single point of view, it might have taken 0% of the time to send the question, and 100% of the time to receive the answer, and we wouldn't notice anything from it! However, it is possible to estimate the time this roundtrip takes, and then assume that information travels the same speed both ways - thus deduce that latency is half of our estimated roundtrip. And with that, we have an estimate of what's the time on the host. Note that network conditions may change, thus the remote time is regularly updated by the newest estimate. This also means that the remote time may jump forwards or even backwards, as it's updated. Can be used as a base for comparisons ( e.g. latency ), but not recommended for tying game logic to it. NetworkTime.remote_ticks - Estimated time on the host, in ticks NetwokrTime.remote_time - Estimated time on the host, in seconds NetworkTime.remote_rtt - Estimated roundtrip time to host, in seconds","title":"Remote time"},{"location":"tutorials/ticking-in-sync/#time","text":"\"Regular\" time combines the best of both worlds - it is based on an estimate of the host's time, but doesn't jump around. It is synced to the host once, and then only ever updated in case the clocks go extremely out of sync for whatever reason. Use this as your go-to solution, and specifically when you need to share timestamps between clients - for example sending a message saying Player C fired their gun at tick #357. NetworkTime.time - Network time, in seconds NetworkTime.ticks - Network time, in ticks","title":"Time"},{"location":"tutorials/ticking-in-sync/#utilities","text":"NetworkTime also provides various methods and properties regarding time: NetworkTime.tickrate NetworkTime.ticktime NetworkTime.tick_factor NetworkTime.ticks_to_seconds(ticks) NetworkTime.seconds_to_ticks(seconds) NetworkTime.ticks_between(from_seconds, to_seconds) NetworkTime.seconds_between(from_tick, to_tick) TODO : Reference docs","title":"Utilities"},{"location":"tutorials/ticking-in-sync/#project-settings","text":"Actual tickrate is controlled by project settings, and cannot be changed at runtime. The settings themselves are under Netfox/Time .","title":"Project Settings"}]}