{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"netfox A set of addons for responsive online games with the Godot engine . Features \u23f2\ufe0f Consistent timing across multiple machines \ud83d\udda5\ufe0f Supports client-server architecture \ud83e\uddc8 Smooth motion with easy-to-use interpolation \ud83d\udca8 Lag compensation with Client-side Prediction and Server-side Reconciliation \ud83d\udedc Bullet-proof connectivity with noray integration Overview The package consists of multiple addons, each with different features: netfox The core package, implements timing, rollback and other multiplayer features Start here netfox.noray Implements noray integration to establish connection between players Useful for online games netfox.extras Provides high-level, game-specific, convenience features built on top of netfox, like base classes for input management or weapons Check for reusable components for your game netfox.internals Shared utilities for the other addons Included as dependency, no need to install separately Install Releases Find the latest netfox under Releases Each release contains the addons, and a build of Forest Brawl for Windows and Linux. Each addon has its dependencies packed with it - e.g. \"netfox.extras.vx.y.z.zip\" also contains both netfox and netfox.internals . Note: For releases before v1.1.1, a separate \".with-deps.zip\" version contains the addon and its dependencies, while the regular zips contain only the addon itself. Asset Library Search for the addon name in Godot's AssetLib or download from the site: netfox netfox.noray netfox.extras Source Download the source and copy the addons of your choice to your Godot project. Enable the addons After adding netfox to your project, make sure to enable the addons in your project settings. Otherwise, Godot will present you with errors about undeclared identifiers. Prototyping To try your game online with noray , a free to use instance is hosted at tomfol.io:8890 , the same instance used by Forest Brawl . You can use this noray instance to quickly test your games online, but is not recommended for shipping games. The instance has configured limits, and no uptime guarantees are made. About this documentation These pages assume that you are familiar with both Godot, its multiplayer capabilities, and building multiplayer games in general. Missing any of these might make your reading experience more difficult than preferred. Some links to get you up to speed: Godot Engine docs Godot Engine High-level multiplayer Networking for Physics Programmers About the tutorials The tutorials are intended to get you started fast, but don't explain much of how things work. For that, refer to the guides.","title":"Home"},{"location":"#netfox","text":"A set of addons for responsive online games with the Godot engine .","title":"netfox"},{"location":"#features","text":"\u23f2\ufe0f Consistent timing across multiple machines \ud83d\udda5\ufe0f Supports client-server architecture \ud83e\uddc8 Smooth motion with easy-to-use interpolation \ud83d\udca8 Lag compensation with Client-side Prediction and Server-side Reconciliation \ud83d\udedc Bullet-proof connectivity with noray integration","title":"Features"},{"location":"#overview","text":"The package consists of multiple addons, each with different features: netfox The core package, implements timing, rollback and other multiplayer features Start here netfox.noray Implements noray integration to establish connection between players Useful for online games netfox.extras Provides high-level, game-specific, convenience features built on top of netfox, like base classes for input management or weapons Check for reusable components for your game netfox.internals Shared utilities for the other addons Included as dependency, no need to install separately","title":"Overview"},{"location":"#install","text":"","title":"Install"},{"location":"#releases","text":"Find the latest netfox under Releases Each release contains the addons, and a build of Forest Brawl for Windows and Linux. Each addon has its dependencies packed with it - e.g. \"netfox.extras.vx.y.z.zip\" also contains both netfox and netfox.internals . Note: For releases before v1.1.1, a separate \".with-deps.zip\" version contains the addon and its dependencies, while the regular zips contain only the addon itself.","title":"Releases"},{"location":"#asset-library","text":"Search for the addon name in Godot's AssetLib or download from the site: netfox netfox.noray netfox.extras","title":"Asset Library"},{"location":"#source","text":"Download the source and copy the addons of your choice to your Godot project.","title":"Source"},{"location":"#enable-the-addons","text":"After adding netfox to your project, make sure to enable the addons in your project settings. Otherwise, Godot will present you with errors about undeclared identifiers.","title":"Enable the addons"},{"location":"#prototyping","text":"To try your game online with noray , a free to use instance is hosted at tomfol.io:8890 , the same instance used by Forest Brawl . You can use this noray instance to quickly test your games online, but is not recommended for shipping games. The instance has configured limits, and no uptime guarantees are made.","title":"Prototyping"},{"location":"#about-this-documentation","text":"These pages assume that you are familiar with both Godot, its multiplayer capabilities, and building multiplayer games in general. Missing any of these might make your reading experience more difficult than preferred. Some links to get you up to speed: Godot Engine docs Godot Engine High-level multiplayer Networking for Physics Programmers","title":"About this documentation"},{"location":"#about-the-tutorials","text":"The tutorials are intended to get you started fast, but don't explain much of how things work. For that, refer to the guides.","title":"About the tutorials"},{"location":"upgrading/","text":"Upgrading netfox Improvements are fixes are added to netfox with time, based on user feedback, resulting in newer versions. This page is inteded to help you with upgrading your game to a newer netfox version. General advice Have a backup Make sure to have a backup of your project before upgrading. While most often an addon update should be harmless, it is a good practice to backup your project regularly, and specifically before risky changes. Disable the addon(s) Before upgrading, disable the netfox addon(s) in your project, in Project Settings. After the upgrade, enable the addon(s) again. This helps with cases where an autoload or a project setting is changed. Version-specific steps This section has version-specific entries where extra actions might be necessary. Versions where the general advice holds are left out. Make sure to apply all the steps between the versions, e.g. if you're updating from 1.0.0 to 1.3.0, refer to the sections between the two versions, in this case v1.1.1. If there are no sections here for your version range, that means that the upgrade should need no extra action, aside from replacing the old netfox addon(s) with the new one(s). v1.1.1 Remove Interpolators from the project autoloads, it's a static class now.","title":"Upgrading netfox"},{"location":"upgrading/#upgrading-netfox","text":"Improvements are fixes are added to netfox with time, based on user feedback, resulting in newer versions. This page is inteded to help you with upgrading your game to a newer netfox version.","title":"Upgrading netfox"},{"location":"upgrading/#general-advice","text":"","title":"General advice"},{"location":"upgrading/#have-a-backup","text":"Make sure to have a backup of your project before upgrading. While most often an addon update should be harmless, it is a good practice to backup your project regularly, and specifically before risky changes.","title":"Have a backup"},{"location":"upgrading/#disable-the-addons","text":"Before upgrading, disable the netfox addon(s) in your project, in Project Settings. After the upgrade, enable the addon(s) again. This helps with cases where an autoload or a project setting is changed.","title":"Disable the addon(s)"},{"location":"upgrading/#version-specific-steps","text":"This section has version-specific entries where extra actions might be necessary. Versions where the general advice holds are left out. Make sure to apply all the steps between the versions, e.g. if you're updating from 1.0.0 to 1.3.0, refer to the sections between the two versions, in this case v1.1.1. If there are no sections here for your version range, that means that the upgrade should need no extra action, aside from replacing the old netfox addon(s) with the new one(s).","title":"Version-specific steps"},{"location":"upgrading/#v111","text":"Remove Interpolators from the project autoloads, it's a static class now.","title":"v1.1.1"},{"location":"netfox/concepts/authoritative-servers/","text":"Authoritative servers The idea behind multiplayer servers is replicating state. As long each player sees approximately the same things happening on their screen, the illusion of a shared world works. Naive replication To implement state replication, we could say that each player is responsible for their own state. Players see the effects of their input instantly, as they own their state and thus their avatar. The issue is that clients can't be trusted. Your game client is distributed to players, who run it in various environments. These environments are out of the developer's control, and provide an attack surface for cheats. For example, a modified game client might always report full HP no matter how many hits the player takes. If each player is responsible for their own state, the cheating player's full-HP state will be replicated to everyone else. Server as the source of truth What can be controlled is the server, with dedicated hosting. Thus, the server can be the single source of truth - or in other words, authoritative. Clients send their inputs to the server, and the server responds with the updated game state. This makes cheating difficult, as players have limited influence over the game world. Game code can also be simplified - everything that affects the gameplay is run on the server, while other things such as visual effects are run on the clients. The tradeoff is that it takes time for the updated game state to arrive from the server. This necessitates techniques that mask this delay, such as Client-side prediction and Server reconciliation . Other approaches Server-authoritative gameplay with CSP is not a silver bullet unfortunately, and different games may require different approaches to network state replication. One good example is RTS games. These games can have 50+ or even hundreds of units navigating the map and interacting. Broadcasting all of their state to all of the players from the server may not always be feasible. Instead, players broadcast their actions ( inputs ) to each other and update their game state in lockstep. While this approach can scale up to hundreds of units, it has other drawbacks. One of these is developing the game in such a way that the simulation is exactly the same across multiple CPU architectures down to each bit. For more on this approach, see: 1500 Archers on a 28.8: Network Programming in Age of Empires and Beyond For more approaches, see: Networking for Physics Programmers","title":"Authoritative servers"},{"location":"netfox/concepts/authoritative-servers/#authoritative-servers","text":"The idea behind multiplayer servers is replicating state. As long each player sees approximately the same things happening on their screen, the illusion of a shared world works.","title":"Authoritative servers"},{"location":"netfox/concepts/authoritative-servers/#naive-replication","text":"To implement state replication, we could say that each player is responsible for their own state. Players see the effects of their input instantly, as they own their state and thus their avatar. The issue is that clients can't be trusted. Your game client is distributed to players, who run it in various environments. These environments are out of the developer's control, and provide an attack surface for cheats. For example, a modified game client might always report full HP no matter how many hits the player takes. If each player is responsible for their own state, the cheating player's full-HP state will be replicated to everyone else.","title":"Naive replication"},{"location":"netfox/concepts/authoritative-servers/#server-as-the-source-of-truth","text":"What can be controlled is the server, with dedicated hosting. Thus, the server can be the single source of truth - or in other words, authoritative. Clients send their inputs to the server, and the server responds with the updated game state. This makes cheating difficult, as players have limited influence over the game world. Game code can also be simplified - everything that affects the gameplay is run on the server, while other things such as visual effects are run on the clients. The tradeoff is that it takes time for the updated game state to arrive from the server. This necessitates techniques that mask this delay, such as Client-side prediction and Server reconciliation .","title":"Server as the source of truth"},{"location":"netfox/concepts/authoritative-servers/#other-approaches","text":"Server-authoritative gameplay with CSP is not a silver bullet unfortunately, and different games may require different approaches to network state replication. One good example is RTS games. These games can have 50+ or even hundreds of units navigating the map and interacting. Broadcasting all of their state to all of the players from the server may not always be feasible. Instead, players broadcast their actions ( inputs ) to each other and update their game state in lockstep. While this approach can scale up to hundreds of units, it has other drawbacks. One of these is developing the game in such a way that the simulation is exactly the same across multiple CPU architectures down to each bit. For more on this approach, see: 1500 Archers on a 28.8: Network Programming in Age of Empires and Beyond For more approaches, see: Networking for Physics Programmers","title":"Other approaches"},{"location":"netfox/concepts/servers-clients-ownership/","text":"Servers, clients, and ownership Much of this documentation discusses things in context of servers and clients. This page is intended to clear up how this translates to Godot's concept of multiplayer ownership. Ownership in Godot In Godot's multiplayer system, each node belongs to a multiplayer peer, i.e. a player. This can be set from scripts, and is not replicated. This means that the logic assigning ownership to nodes must produce the same result on every machine for things to work consistently. Ownership in netfox To mesh better with Godot's existing conventions, netfox doesn't work in terms of server and client, but uses ownership instead. Whenever the server is mentioned, it refers to a given node's owner. In practice, this means that nodes representing game state are and should be owned by the server. Limitations At the time of writing, ownership is hard-coded in some cases. One such case is NetworkTime , which is always owned by the host peer and always takes the host peer's time as reference. This means that peer-to-peer games are not officially supported by netfox , but might be able to work with some workarounds. If feasible, you can build self-hosted games by including netfox.noray . In theory, multiple players can own different parts of the game state, but netfox is not tested for such use cases.","title":"Servers, clients, and ownership"},{"location":"netfox/concepts/servers-clients-ownership/#servers-clients-and-ownership","text":"Much of this documentation discusses things in context of servers and clients. This page is intended to clear up how this translates to Godot's concept of multiplayer ownership.","title":"Servers, clients, and ownership"},{"location":"netfox/concepts/servers-clients-ownership/#ownership-in-godot","text":"In Godot's multiplayer system, each node belongs to a multiplayer peer, i.e. a player. This can be set from scripts, and is not replicated. This means that the logic assigning ownership to nodes must produce the same result on every machine for things to work consistently.","title":"Ownership in Godot"},{"location":"netfox/concepts/servers-clients-ownership/#ownership-in-netfox","text":"To mesh better with Godot's existing conventions, netfox doesn't work in terms of server and client, but uses ownership instead. Whenever the server is mentioned, it refers to a given node's owner. In practice, this means that nodes representing game state are and should be owned by the server.","title":"Ownership in netfox"},{"location":"netfox/concepts/servers-clients-ownership/#limitations","text":"At the time of writing, ownership is hard-coded in some cases. One such case is NetworkTime , which is always owned by the host peer and always takes the host peer's time as reference. This means that peer-to-peer games are not officially supported by netfox , but might be able to work with some workarounds. If feasible, you can build self-hosted games by including netfox.noray . In theory, multiple players can own different parts of the game state, but netfox is not tested for such use cases.","title":"Limitations"},{"location":"netfox/guides/interpolators/","text":"Interpolators Tracks interpolators for various data types. Provided as an autoload. To smooth out motion between network ticks, TickInterpolator interpolates nodes' state properties between the current and the previous tick. The type of data to be interpolated is not known in advance, and can be any built-in or even custom type configured by the developer. Interpolators provides methods to register interpolators for any data type, and even provides some for built-in data types. Interpolating values Interpolators can be used to interpolate between any two values, as long as they hold the same data type: extends Node3D @export var target_node @export var approach_time = 0.5 func _process(delta): # Approach target node, if it exists if target_node: var from_xform = global_transform var to_xform = target_node.global_transform var factor = delta / approach_time global_transform = Interpolators.interpolate(from_xform, to_xform, factor) Note that in this case, Interpolators will try to look up the appropriate interpolator based on the provided values. If no interpolator is found, a fallback is used, that simply returns the value closer to factor - i.e. the starting value if factor is less than 0.5 and the target value otherwise. Caching interpolators To avoid having to look up the right interpolator every frame, you can cache it: extends Node3D @export target_node @export approach_time = 0.5 var interpolator func _ready(): interpolator = Interpolators.find_for(global_transform) func _process(delta): # Approach target node, if it exists if target_node: var from_xform = global_transform var to_xform = target_node.global_transform var factor = delta / approach_time global_transform = interpolator.call(from_xform, to_xform, factor) Custom interpolators Interpolators supports interpolators for custom data types, and even overriding built-in interpolators. Both can be done by registering an interpolator: Interpolators.register( func(a): return a is float, # Condition func(a, b, f): return lerpf(a, b, f * f) # Interpolation ) The above registers a custom interpolator by specifying a condition function and an interpolation function. Since it applies to an already supported type, it overrides the built-in interpolator. During lookup, Interpolators calls the condition function of each interpolator and returns the one whose condition function returns true. If multiple interpolators are applicable, Interpolators returns the last registered one. The interpolation function receives the starting value a , the target value b and the interpolation factor f . Built-in interpolators The following types are supported by default: float Vector2 Vector3 Transform2D Transform3D","title":"Interpolators"},{"location":"netfox/guides/interpolators/#interpolators","text":"Tracks interpolators for various data types. Provided as an autoload. To smooth out motion between network ticks, TickInterpolator interpolates nodes' state properties between the current and the previous tick. The type of data to be interpolated is not known in advance, and can be any built-in or even custom type configured by the developer. Interpolators provides methods to register interpolators for any data type, and even provides some for built-in data types.","title":"Interpolators"},{"location":"netfox/guides/interpolators/#interpolating-values","text":"Interpolators can be used to interpolate between any two values, as long as they hold the same data type: extends Node3D @export var target_node @export var approach_time = 0.5 func _process(delta): # Approach target node, if it exists if target_node: var from_xform = global_transform var to_xform = target_node.global_transform var factor = delta / approach_time global_transform = Interpolators.interpolate(from_xform, to_xform, factor) Note that in this case, Interpolators will try to look up the appropriate interpolator based on the provided values. If no interpolator is found, a fallback is used, that simply returns the value closer to factor - i.e. the starting value if factor is less than 0.5 and the target value otherwise.","title":"Interpolating values"},{"location":"netfox/guides/interpolators/#caching-interpolators","text":"To avoid having to look up the right interpolator every frame, you can cache it: extends Node3D @export target_node @export approach_time = 0.5 var interpolator func _ready(): interpolator = Interpolators.find_for(global_transform) func _process(delta): # Approach target node, if it exists if target_node: var from_xform = global_transform var to_xform = target_node.global_transform var factor = delta / approach_time global_transform = interpolator.call(from_xform, to_xform, factor)","title":"Caching interpolators"},{"location":"netfox/guides/interpolators/#custom-interpolators","text":"Interpolators supports interpolators for custom data types, and even overriding built-in interpolators. Both can be done by registering an interpolator: Interpolators.register( func(a): return a is float, # Condition func(a, b, f): return lerpf(a, b, f * f) # Interpolation ) The above registers a custom interpolator by specifying a condition function and an interpolation function. Since it applies to an already supported type, it overrides the built-in interpolator. During lookup, Interpolators calls the condition function of each interpolator and returns the one whose condition function returns true. If multiple interpolators are applicable, Interpolators returns the last registered one. The interpolation function receives the starting value a , the target value b and the interpolation factor f .","title":"Custom interpolators"},{"location":"netfox/guides/interpolators/#built-in-interpolators","text":"The following types are supported by default: float Vector2 Vector3 Transform2D Transform3D","title":"Built-in interpolators"},{"location":"netfox/guides/logging/","text":"Logging During runtime, it can be useful to print some diagnostic info to the console - this is called logging. The netfox addons include various log messages to help with debugging. This is useful when running the game locally, but also helps if there's log files players can attach with their bug reports. Depending on your game, different logs may be needed. To accommodate this, netfox can be configured to omit certain log messages. Log levels Each log message can be in one of the following categories: Error Something goes irrecoverably wrong, or something that should never happen just happened Warning Something goes wrong, but can be handled Info Useful information on expected behaviour Debug Verbose messages, to help debug general code flow Trace Extremely verbose messages, to help follow the code flow to the smallest detail Log messages Log messages from any of the netfox addons are prefixed with log level, module and logging class / object: [INF][netfox.noray::Noray] Trying to connect to noray at tomfol.io:8890 [DBG][netfox.noray::Noray] Resolved noray host to 172.105.69.73 [INF][netfox.noray::Noray] Connected to noray at 172.105.69.73:8890 [DBG][netfox.noray::Noray] Saved OID: 6JeDH07eVuFu5SO0p-6X2 [DBG][netfox.noray::Noray] Bound UDP to port 47769 [DBG][netfox.noray::Noray] Saved PID: vw6_N9sT2N0tXaYke9SV9ReWCgtdsOdfeL1o9zkCL93U7KzBjgMZ7hShBXpf_WYOB_TthARt4GfzH1iLxXR7iR3WCebzx9Sf108e8wUoqwTJqm9bIdVxyYoQUBFT9h2M [INF][netfox.noray::Noray] Registered local port 47769 to remote This makes it easier to gather info at a glance. Settings These settings control the minimum log level - e.g. if the log level is set to info , only messages at or above the info level will be logged, namely info, warning and error. If the setting is set to all , all messages are logged. Log levels can be controlled globally and per addon. A message will be logged if it passes both logging level checks. For example, if the Log Level setting is at Warning and the Netfox Log Level is at Info , only warning and error messages are logged for netfox. This happens because the Log Level is more restrictive than the Netfox Log Level setting. Note that you don't need to install all netfox addons for the logging settings to work. If an addon is not installed, its log level setting is simply ignored.","title":"Logging"},{"location":"netfox/guides/logging/#logging","text":"During runtime, it can be useful to print some diagnostic info to the console - this is called logging. The netfox addons include various log messages to help with debugging. This is useful when running the game locally, but also helps if there's log files players can attach with their bug reports. Depending on your game, different logs may be needed. To accommodate this, netfox can be configured to omit certain log messages.","title":"Logging"},{"location":"netfox/guides/logging/#log-levels","text":"Each log message can be in one of the following categories: Error Something goes irrecoverably wrong, or something that should never happen just happened Warning Something goes wrong, but can be handled Info Useful information on expected behaviour Debug Verbose messages, to help debug general code flow Trace Extremely verbose messages, to help follow the code flow to the smallest detail","title":"Log levels"},{"location":"netfox/guides/logging/#log-messages","text":"Log messages from any of the netfox addons are prefixed with log level, module and logging class / object: [INF][netfox.noray::Noray] Trying to connect to noray at tomfol.io:8890 [DBG][netfox.noray::Noray] Resolved noray host to 172.105.69.73 [INF][netfox.noray::Noray] Connected to noray at 172.105.69.73:8890 [DBG][netfox.noray::Noray] Saved OID: 6JeDH07eVuFu5SO0p-6X2 [DBG][netfox.noray::Noray] Bound UDP to port 47769 [DBG][netfox.noray::Noray] Saved PID: vw6_N9sT2N0tXaYke9SV9ReWCgtdsOdfeL1o9zkCL93U7KzBjgMZ7hShBXpf_WYOB_TthARt4GfzH1iLxXR7iR3WCebzx9Sf108e8wUoqwTJqm9bIdVxyYoQUBFT9h2M [INF][netfox.noray::Noray] Registered local port 47769 to remote This makes it easier to gather info at a glance.","title":"Log messages"},{"location":"netfox/guides/logging/#settings","text":"These settings control the minimum log level - e.g. if the log level is set to info , only messages at or above the info level will be logged, namely info, warning and error. If the setting is set to all , all messages are logged. Log levels can be controlled globally and per addon. A message will be logged if it passes both logging level checks. For example, if the Log Level setting is at Warning and the Netfox Log Level is at Info , only warning and error messages are logged for netfox. This happens because the Log Level is more restrictive than the Netfox Log Level setting. Note that you don't need to install all netfox addons for the logging settings to work. If an addon is not installed, its log level setting is simply ignored.","title":"Settings"},{"location":"netfox/guides/network-events/","text":"NetworkEvents Provides convenience signals for multiplayer games. Included as an autoload. Keeps track of the root multiplayer instance and fires signals when it changes. Using NetworkEvents ' signals are safe even when the multiplayer instance changes, as the signals are updated upon instance change. Provides missing signals for server start and server stop events. NetworkTime When enabled, NetworkEvents will start NetworkTime when it detects that a server or a client is started. It will stop NetworkTime , when it detects that the currently running server or client is stopped. Settings Settings are found in the Project Settings, under Netfox > Events: Enabled toggles network events. When disabled, NetworkEvents will not emit any events or track the multiplayer instance. This may slightly improve performance, as it completely stops Godot from processing the NetworkEvents node.","title":"NetworkEvents"},{"location":"netfox/guides/network-events/#networkevents","text":"Provides convenience signals for multiplayer games. Included as an autoload. Keeps track of the root multiplayer instance and fires signals when it changes. Using NetworkEvents ' signals are safe even when the multiplayer instance changes, as the signals are updated upon instance change. Provides missing signals for server start and server stop events.","title":"NetworkEvents"},{"location":"netfox/guides/network-events/#networktime","text":"When enabled, NetworkEvents will start NetworkTime when it detects that a server or a client is started. It will stop NetworkTime , when it detects that the currently running server or client is stopped.","title":"NetworkTime"},{"location":"netfox/guides/network-events/#settings","text":"Settings are found in the Project Settings, under Netfox > Events: Enabled toggles network events. When disabled, NetworkEvents will not emit any events or track the multiplayer instance. This may slightly improve performance, as it completely stops Godot from processing the NetworkEvents node.","title":"Settings"},{"location":"netfox/guides/network-performance/","text":"NetworkPerformance Provides custom monitors for measuring networking performance. Included as an autoload. Enabling monitoring By default, network performance monitoring is only enabled in debug builds and when running from the editor. Use the netfox_noperf feature tag to force disable network performance monitors. Use the netfox_perf feature tag to force enable network performance monitors. These feature tags enable customization for each export preset. Performance monitors Network loop duration Network loop duration measures the time spent in the network tick loop . Note that this includes time spent on the rollback loop as well. This value is updated once for every tick loop, it is not reset to zero after the loop has run. This means that you may get a non-zero reading, even if the tick loop is currently not running. Rollback loop duration Rollback loop duration measures the time spent in the last rollback loop . This includes all of its steps. The value of this monitor may be zero, if no players have joined, no nodes use rollback, or rollback is disabled. Network ticks simulated Network ticks simulated measures the number of ticks run in the last network tick loop . If the game runs at a higher FPS than the network tickrate, this value should be consistently one. Higher, stable values mean that the game itself runs slower than the network tickrate, and needs to catch up by running multiple ticks on each frame. Rollback ticks simulated Rollback ticks simulated measures the number of rollback ticks run in the last rollback loop . Generally, this denotes the age of the oldest input or state received, depending on whether the game is running as a server or client. The measurement is strongly correlated to network latency - the higher the latency, the older the state and input packets will be upon arrival. The more rollback ticks need to be simulated, the more work the rollback tick has to do, which can negatively affect performance. Rollback tick duration Rollback tick duration provides the average time spent simulating a single tick in the last rollback loop . This can be useful to determine if the rollback tick duration comes from too many ticks being simulated, or the individual ticks being expensive to simulate ( or both ).","title":"NetworkPerformance"},{"location":"netfox/guides/network-performance/#networkperformance","text":"Provides custom monitors for measuring networking performance. Included as an autoload.","title":"NetworkPerformance"},{"location":"netfox/guides/network-performance/#enabling-monitoring","text":"By default, network performance monitoring is only enabled in debug builds and when running from the editor. Use the netfox_noperf feature tag to force disable network performance monitors. Use the netfox_perf feature tag to force enable network performance monitors. These feature tags enable customization for each export preset.","title":"Enabling monitoring"},{"location":"netfox/guides/network-performance/#performance-monitors","text":"","title":"Performance monitors"},{"location":"netfox/guides/network-performance/#network-loop-duration","text":"Network loop duration measures the time spent in the network tick loop . Note that this includes time spent on the rollback loop as well. This value is updated once for every tick loop, it is not reset to zero after the loop has run. This means that you may get a non-zero reading, even if the tick loop is currently not running.","title":"Network loop duration"},{"location":"netfox/guides/network-performance/#rollback-loop-duration","text":"Rollback loop duration measures the time spent in the last rollback loop . This includes all of its steps. The value of this monitor may be zero, if no players have joined, no nodes use rollback, or rollback is disabled.","title":"Rollback loop duration"},{"location":"netfox/guides/network-performance/#network-ticks-simulated","text":"Network ticks simulated measures the number of ticks run in the last network tick loop . If the game runs at a higher FPS than the network tickrate, this value should be consistently one. Higher, stable values mean that the game itself runs slower than the network tickrate, and needs to catch up by running multiple ticks on each frame.","title":"Network ticks simulated"},{"location":"netfox/guides/network-performance/#rollback-ticks-simulated","text":"Rollback ticks simulated measures the number of rollback ticks run in the last rollback loop . Generally, this denotes the age of the oldest input or state received, depending on whether the game is running as a server or client. The measurement is strongly correlated to network latency - the higher the latency, the older the state and input packets will be upon arrival. The more rollback ticks need to be simulated, the more work the rollback tick has to do, which can negatively affect performance.","title":"Rollback ticks simulated"},{"location":"netfox/guides/network-performance/#rollback-tick-duration","text":"Rollback tick duration provides the average time spent simulating a single tick in the last rollback loop . This can be useful to determine if the rollback tick duration comes from too many ticks being simulated, or the individual ticks being expensive to simulate ( or both ).","title":"Rollback tick duration"},{"location":"netfox/guides/network-rollback/","text":"NetworkRollback Orchestrates the network rollback loop. Provided as an autoload. Due to latency, the server may receive inputs from clients from multiple ticks ago. Whenever this happens, the server rewinds its time and resimulates the whole game from the time of the new input. The resimulated ticks are then sent to clients to update their state. Also due to latency, clients may receive a state from the server that is several ticks old. Clients rewind their simulation to the time of the latest received state and resimulate from there. On both clients and servers, simulated states are recorded for reuse later. Further reading: Client-Side Prediction and Server Reconciliation Note that most of the time you do not need to use this class - the RollbackSynchronizer node helps with writing rollback-aware behaviour. Network rollback loop NetworkRollback runs the network rollback loop after every network tick, but before the after tick signal is fired. The following is the network rollback loop in isolation: Signal handlers must implement the right steps for rollback to work. During before_loop , all rollback-aware nodes must submit where to start the resimulation, by calling NetworkRollback.notify_resimulation_start . Resimulation will begin from the earliest tick submitted. In each on_prepare_tick(tick) handler, nodes must rewind their state to the specified tick. If a state is not available for the given tick, use the latest tick that is earlier than the given tick. Nodes may also register themselves as being simulated by calling NetworkRollback.notify_simulated . This is not used by NetworkRollback itself, but can be used by other nodes to check which nodes are simulated in the current rollback tick. For the on_process_tick(tick) signal, nodes must advance their simulation by a single tick. In on_record_tick(tick) , nodes must record their state for the given tick. Note that since the simulation was advanced by one tick in the previous signal, the tick parameter is incremented here. The after_loop signal notifies its subscribers that the resimulation is done. This can be used to change to the state that is appropriate for display. The network rollback loop is part of the network tick loop as follows: Conditional simulation During rollback, NetworkRollback loops over the full range of ticks to resimulate. Some nodes may not need to be resimulated for the current tick, e.g. because they don't have input for the current tick. NetworkRollback can be used to track nodes that will be simulated in the current rollback tick. Register nodes that will be simulated by calling NetworkRollback.notify_simulated . To check if a node has been registered, call NetworkRollback.is_simulated . Rollback-awareness RollbackSynchronizer considers nodes rollback-aware that implement the _rollback_tick method. Rollback-aware nodes are nodes that can participate in the rollback process, i.e. they can resimulate earlier ticks. To check if a node is rollback-aware, call NetworkRollback.is_rollback_aware . To actually run a rollback tick on them, call NetworkRollback.process_rollback . These methods are called by RollbackSynchronizer under the hood. Settings Enabled toggles network rollback. No signals are fired when disabled. History limit is the maximum number of recorded ticks to keep. Larger values enable further rewinds and thus larger latencies, but consume more memory for each node that is recorded. Input redundancy This is the number of previous input ticks to send along with the current tick. We send data unreliably over UDP for speed. In the event a packet is lost or arrives out of order we add some redundancy. You can calculate your target reliability % packet success chance by using the formula 1 - (1 - packet_success_rate) ^ input_redundancy . Display offset specifies the age of the tick to display. By displaying an older state instead of the latest one, games can mask adjustments if a state update is received from the server. The drawback is that the game will have some latency built-in, as it reacts to player inputs with some delay. Setting to zero will always display the latest game state.","title":"NetworkRollback"},{"location":"netfox/guides/network-rollback/#networkrollback","text":"Orchestrates the network rollback loop. Provided as an autoload. Due to latency, the server may receive inputs from clients from multiple ticks ago. Whenever this happens, the server rewinds its time and resimulates the whole game from the time of the new input. The resimulated ticks are then sent to clients to update their state. Also due to latency, clients may receive a state from the server that is several ticks old. Clients rewind their simulation to the time of the latest received state and resimulate from there. On both clients and servers, simulated states are recorded for reuse later. Further reading: Client-Side Prediction and Server Reconciliation Note that most of the time you do not need to use this class - the RollbackSynchronizer node helps with writing rollback-aware behaviour.","title":"NetworkRollback"},{"location":"netfox/guides/network-rollback/#network-rollback-loop","text":"NetworkRollback runs the network rollback loop after every network tick, but before the after tick signal is fired. The following is the network rollback loop in isolation: Signal handlers must implement the right steps for rollback to work. During before_loop , all rollback-aware nodes must submit where to start the resimulation, by calling NetworkRollback.notify_resimulation_start . Resimulation will begin from the earliest tick submitted. In each on_prepare_tick(tick) handler, nodes must rewind their state to the specified tick. If a state is not available for the given tick, use the latest tick that is earlier than the given tick. Nodes may also register themselves as being simulated by calling NetworkRollback.notify_simulated . This is not used by NetworkRollback itself, but can be used by other nodes to check which nodes are simulated in the current rollback tick. For the on_process_tick(tick) signal, nodes must advance their simulation by a single tick. In on_record_tick(tick) , nodes must record their state for the given tick. Note that since the simulation was advanced by one tick in the previous signal, the tick parameter is incremented here. The after_loop signal notifies its subscribers that the resimulation is done. This can be used to change to the state that is appropriate for display. The network rollback loop is part of the network tick loop as follows:","title":"Network rollback loop"},{"location":"netfox/guides/network-rollback/#conditional-simulation","text":"During rollback, NetworkRollback loops over the full range of ticks to resimulate. Some nodes may not need to be resimulated for the current tick, e.g. because they don't have input for the current tick. NetworkRollback can be used to track nodes that will be simulated in the current rollback tick. Register nodes that will be simulated by calling NetworkRollback.notify_simulated . To check if a node has been registered, call NetworkRollback.is_simulated .","title":"Conditional simulation"},{"location":"netfox/guides/network-rollback/#rollback-awareness","text":"RollbackSynchronizer considers nodes rollback-aware that implement the _rollback_tick method. Rollback-aware nodes are nodes that can participate in the rollback process, i.e. they can resimulate earlier ticks. To check if a node is rollback-aware, call NetworkRollback.is_rollback_aware . To actually run a rollback tick on them, call NetworkRollback.process_rollback . These methods are called by RollbackSynchronizer under the hood.","title":"Rollback-awareness"},{"location":"netfox/guides/network-rollback/#settings","text":"Enabled toggles network rollback. No signals are fired when disabled. History limit is the maximum number of recorded ticks to keep. Larger values enable further rewinds and thus larger latencies, but consume more memory for each node that is recorded. Input redundancy This is the number of previous input ticks to send along with the current tick. We send data unreliably over UDP for speed. In the event a packet is lost or arrives out of order we add some redundancy. You can calculate your target reliability % packet success chance by using the formula 1 - (1 - packet_success_rate) ^ input_redundancy . Display offset specifies the age of the tick to display. By displaying an older state instead of the latest one, games can mask adjustments if a state update is received from the server. The drawback is that the game will have some latency built-in, as it reacts to player inputs with some delay. Setting to zero will always display the latest game state.","title":"Settings"},{"location":"netfox/guides/network-time-synchronizer/","text":"NetworkTimeSynchronizer Synchronizes time towards a target peer. Provided as an autoload. Synchronization is run periodically in a loop. During synchronization, the NetworkTimeSynchronizer measures the roundtrip to the target peer, assumes latency is half of the roundtrip, and adds the latency to the latest time received from the target peer. To estimate the roundtrip time, it sends multiple ping messages to the target peer, measuring how much time it takes to get a response. Measurements that are too far from the average are rejected to filter out latency spikes. Further reading: Time, Tick, Clock Synchronisation Most of the time you shouldn't need to interface with this class directly, instead you can use NetworkTime .","title":"NetworkTimeSynchronizer"},{"location":"netfox/guides/network-time-synchronizer/#networktimesynchronizer","text":"Synchronizes time towards a target peer. Provided as an autoload. Synchronization is run periodically in a loop. During synchronization, the NetworkTimeSynchronizer measures the roundtrip to the target peer, assumes latency is half of the roundtrip, and adds the latency to the latest time received from the target peer. To estimate the roundtrip time, it sends multiple ping messages to the target peer, measuring how much time it takes to get a response. Measurements that are too far from the average are rejected to filter out latency spikes. Further reading: Time, Tick, Clock Synchronisation Most of the time you shouldn't need to interface with this class directly, instead you can use NetworkTime .","title":"NetworkTimeSynchronizer"},{"location":"netfox/guides/network-time/","text":"NetworkTime Tracks shared network time between players, and provides an event loop for synchronized game updates. Provided as an autoload. A separate timer is provided for network ticks, making the network game update rate independent from rendering or physics frames. Network tick loop NetworkTime provides its own independent event loop by exposing signals. This makes networked game logic independent of current FPS, and makes it run at a consistent rate. Connect handlers to NetworkTime 's signals to implement networked game logic. During each frame, NetworkTime checks how much time has elapsed since the last tick loop. When more time has elapsed than a single tick's duration, the network tick loop will run: The tick loop will run as long as it catches up on ticks to run. Every loop is limited to run at most max_ticks_per_frame ticks to avoid overwhelming the CPU. To tie the network tick loop to Godot's physics process, enable sync_to_physics . This will result in the tick loop running a single tick in every physics update. To move your game logic to the network tick loop, use the on_tick event: extends Node3D @export var speed = 4.0 func _ready(): NetworkTime.on_tick.connect(_tick) func _tick(delta, tick): # Move forward position += basis.z * delta * speed By convention, on_tick handlers are named _tick . Starting and stopping By default, NetworkTime does not run the tick loop at all. This lets you control when the network tick loop, and thus the game starts and stops. To start the tick loop, call the NetworkTime.start() coroutine. On servers, this will start the tick loop and return immediately. On clients, it will first synchronize the time to the server, start the network tick loop, and only then return. Use this when starting the game. Starting the tick loop before starting multiplayer is not supported. To stop the tick loop, call NetworkTime.stop() . This will immediately stop the tick loop and return. Use this when the player leaves a game. To get notified when a client successfully syncs their time and starts the tick loop, use the NetworkTime.after_client_sync(peer_id) signal. This is fired once per client, and only on the server. Pausing NetworkTime also supports pausing the game, if needed. There's two cases where pauses are considered. When running ( and pausing ) the game from the editor, the network tick loop is automatically paused. As there's currently no API to detect the editor pausing the game, NetworkTime checks if Godot's _process delta and actual delta is mismatching, and if so, considers the game paused. In some cases, this can result in false positives when the game simply hangs for a bit, e.g. when loading resources. This pause detection only happens when the game is run from the editor, to avoid false positives in production builds. The other supported case is pausing the game from the engine itself. Whenever SceneTree.paused is set to true, NetworkTime won't run the tick loop. Note that pausing the tick loop can cause desynchronization between peers, and could lead to clients fast-forwarding ticks to catch up, or time recalibrations. If the game is paused via SceneTree, make sure it is paused and unpaused at the same time on all peers. Time synchronization NetworkTime runs a time synchronization loop on clients, in the background. Synchronizing time makes sure that all players have a shared idea of time and can exchange timing-related data. The synchronization itself is handled by NetworkTimeSynchronizer . NetworkTime provides different kinds of time, each for different use cases. Each time can be accessed as ticks or seconds. Both advance after every network tick. Local time NetworkTime.local_time NetworkTime.local_ticks Marks the current time in reference to the local machine. Starts at zero when the network tick loop starts. Useful for logic that is tied to the tick loop, but is not synchronized over the network. A good example is visual effects. Not suitable for synchronizing data, as the local time is different at each player. Remote time NetworkTime.remote_ticks NetwokrTime.remote_time NetworkTime.remote_rtt Marks the current estimated time of the server. This is a regularly updated estimate. Note that on each update, the remote time may jump forwards or even backwards. The estimate is based on the measured roundtrip time ( remote_rtt ) and the assumption that the latency is exactly half of that. Can be used as a base for comparisons ( e.g. latency ), but not recommended for tying game logic to it. To get notified when a time synchronization happens and the remote time is updated, use the NetworkTime.after_sync signal. Time NetworkTime.time NetworkTime.ticks Marks the current network game time. On start, this time is set to the estimated remote time. The game time is only adjusted if it is too far off from the remote time, making it a good, consistent source of time. Can be used when timing data needs to be shared between players, and for game logic that is synchronized over the network. Settings Settings are found in the Project Settings, under Netfox > Time: Tickrate specifies the number of ticks every second in the network tick loop. Max Ticks Per Frame sets the maximum number of frames to simulate per tick loop. Used to avoid freezing the game under load. Recalibrate Threshold is the largest allowed time discrepancy in seconds. If the difference between the remote time and game time is larger than this setting, the game time will be reset to the remote time. Sync Interval is the resting time between time synchronizations. Note that the synchronization itself may take multiple seconds, so overall there will be more time between two synchronization runs than just the interval. Sync Samples is the number of measurements to take for estimating roundtrip time. Sync Sample Interval is the resting time between roundtrip measurements. Sync to Physics ties the network tick loop to the physics process when enabled.","title":"NetworkTime"},{"location":"netfox/guides/network-time/#networktime","text":"Tracks shared network time between players, and provides an event loop for synchronized game updates. Provided as an autoload. A separate timer is provided for network ticks, making the network game update rate independent from rendering or physics frames.","title":"NetworkTime"},{"location":"netfox/guides/network-time/#network-tick-loop","text":"NetworkTime provides its own independent event loop by exposing signals. This makes networked game logic independent of current FPS, and makes it run at a consistent rate. Connect handlers to NetworkTime 's signals to implement networked game logic. During each frame, NetworkTime checks how much time has elapsed since the last tick loop. When more time has elapsed than a single tick's duration, the network tick loop will run: The tick loop will run as long as it catches up on ticks to run. Every loop is limited to run at most max_ticks_per_frame ticks to avoid overwhelming the CPU. To tie the network tick loop to Godot's physics process, enable sync_to_physics . This will result in the tick loop running a single tick in every physics update. To move your game logic to the network tick loop, use the on_tick event: extends Node3D @export var speed = 4.0 func _ready(): NetworkTime.on_tick.connect(_tick) func _tick(delta, tick): # Move forward position += basis.z * delta * speed By convention, on_tick handlers are named _tick .","title":"Network tick loop"},{"location":"netfox/guides/network-time/#starting-and-stopping","text":"By default, NetworkTime does not run the tick loop at all. This lets you control when the network tick loop, and thus the game starts and stops. To start the tick loop, call the NetworkTime.start() coroutine. On servers, this will start the tick loop and return immediately. On clients, it will first synchronize the time to the server, start the network tick loop, and only then return. Use this when starting the game. Starting the tick loop before starting multiplayer is not supported. To stop the tick loop, call NetworkTime.stop() . This will immediately stop the tick loop and return. Use this when the player leaves a game. To get notified when a client successfully syncs their time and starts the tick loop, use the NetworkTime.after_client_sync(peer_id) signal. This is fired once per client, and only on the server.","title":"Starting and stopping"},{"location":"netfox/guides/network-time/#pausing","text":"NetworkTime also supports pausing the game, if needed. There's two cases where pauses are considered. When running ( and pausing ) the game from the editor, the network tick loop is automatically paused. As there's currently no API to detect the editor pausing the game, NetworkTime checks if Godot's _process delta and actual delta is mismatching, and if so, considers the game paused. In some cases, this can result in false positives when the game simply hangs for a bit, e.g. when loading resources. This pause detection only happens when the game is run from the editor, to avoid false positives in production builds. The other supported case is pausing the game from the engine itself. Whenever SceneTree.paused is set to true, NetworkTime won't run the tick loop. Note that pausing the tick loop can cause desynchronization between peers, and could lead to clients fast-forwarding ticks to catch up, or time recalibrations. If the game is paused via SceneTree, make sure it is paused and unpaused at the same time on all peers.","title":"Pausing"},{"location":"netfox/guides/network-time/#time-synchronization","text":"NetworkTime runs a time synchronization loop on clients, in the background. Synchronizing time makes sure that all players have a shared idea of time and can exchange timing-related data. The synchronization itself is handled by NetworkTimeSynchronizer . NetworkTime provides different kinds of time, each for different use cases. Each time can be accessed as ticks or seconds. Both advance after every network tick.","title":"Time synchronization"},{"location":"netfox/guides/network-time/#local-time","text":"NetworkTime.local_time NetworkTime.local_ticks Marks the current time in reference to the local machine. Starts at zero when the network tick loop starts. Useful for logic that is tied to the tick loop, but is not synchronized over the network. A good example is visual effects. Not suitable for synchronizing data, as the local time is different at each player.","title":"Local time"},{"location":"netfox/guides/network-time/#remote-time","text":"NetworkTime.remote_ticks NetwokrTime.remote_time NetworkTime.remote_rtt Marks the current estimated time of the server. This is a regularly updated estimate. Note that on each update, the remote time may jump forwards or even backwards. The estimate is based on the measured roundtrip time ( remote_rtt ) and the assumption that the latency is exactly half of that. Can be used as a base for comparisons ( e.g. latency ), but not recommended for tying game logic to it. To get notified when a time synchronization happens and the remote time is updated, use the NetworkTime.after_sync signal.","title":"Remote time"},{"location":"netfox/guides/network-time/#time","text":"NetworkTime.time NetworkTime.ticks Marks the current network game time. On start, this time is set to the estimated remote time. The game time is only adjusted if it is too far off from the remote time, making it a good, consistent source of time. Can be used when timing data needs to be shared between players, and for game logic that is synchronized over the network.","title":"Time"},{"location":"netfox/guides/network-time/#settings","text":"Settings are found in the Project Settings, under Netfox > Time: Tickrate specifies the number of ticks every second in the network tick loop. Max Ticks Per Frame sets the maximum number of frames to simulate per tick loop. Used to avoid freezing the game under load. Recalibrate Threshold is the largest allowed time discrepancy in seconds. If the difference between the remote time and game time is larger than this setting, the game time will be reset to the remote time. Sync Interval is the resting time between time synchronizations. Note that the synchronization itself may take multiple seconds, so overall there will be more time between two synchronization runs than just the interval. Sync Samples is the number of measurements to take for estimating roundtrip time. Sync Sample Interval is the resting time between roundtrip measurements. Sync to Physics ties the network tick loop to the physics process when enabled.","title":"Settings"},{"location":"netfox/guides/property-paths/","text":"Property paths Multiple nodes have properties as their configurations. These are specified as property paths , which have a specific syntax. These nodes have a Root property. During path resolution, this Root node is taken as base for relative paths. Syntax Property paths are specified as follows: <node-path>:<property-name> Node path can be empty if it refers to a property on the root node. If specified, node path will be interpreted relative to the root node. Any valid NodePath will work as expected. Nested properties are also supported. Specify them by appending a colon and an additional property name. With Brawler as root: :position refers to the Brawler's position Input:aim refers to the Input's aim :velocity:x refers to the Brawler's velocity's X component; this is a nested property","title":"Property paths"},{"location":"netfox/guides/property-paths/#property-paths","text":"Multiple nodes have properties as their configurations. These are specified as property paths , which have a specific syntax. These nodes have a Root property. During path resolution, this Root node is taken as base for relative paths.","title":"Property paths"},{"location":"netfox/guides/property-paths/#syntax","text":"Property paths are specified as follows: <node-path>:<property-name> Node path can be empty if it refers to a property on the root node. If specified, node path will be interpreted relative to the root node. Any valid NodePath will work as expected. Nested properties are also supported. Specify them by appending a colon and an additional property name. With Brawler as root: :position refers to the Brawler's position Input:aim refers to the Input's aim :velocity:x refers to the Brawler's velocity's X component; this is a nested property","title":"Syntax"},{"location":"netfox/nodes/rollback-synchronizer/","text":"RollbackSynchronizer Manages state during the network rollback loop by hooking into NetworkRollback events. Simulates nodes as required during rollback. Configuring state and input To use RollbackSynchronizer , add it as a child to the target node, specify the root node, and configure which properties to manage: Root specifies the root node for resolving state and input properties. Best practice dictates to add RollbackSynchronizer under its target, so Root will most often be the RollbackSynchronizer 's parent node. State properties are recorded for each tick and restored during rollback. For state, the server is the ultimate authority. Make sure that nodes containing state properties are owned by the server. Input properties are gathered for each player and sent to the server to use for simulation. Make sure that nodes containing input properties are owned by their respective players. See Property paths on how to specify properties. enable_input_broadcast toggles whether input properties are broadcast to all peers, or only to the server. The default is true to support legacy behaviour. It is recommended to turn this off to lower bandwidth and lessen the attack surface for cheating. Note that it is not recommended to have both state and input properties on the same node. Since nodes with state belong to the server, and nodes with input belong to the player, it is difficult to separate ownership on the same node. Writing rollback-aware scripts During setup, RollbackSynchronizer finds all the rollback-aware nodes under the specified root . During rollback, it will call all the rollback-aware nodes to simulate new state. To learn about rollback-awareness, see NetworkRollback . In short, implement _rollback_tick in your scripts: extends CharacterBody3D @export var speed = 4.0 @export var input: PlayerInput func _rollback_tick(delta, tick, is_fresh): velocity = input.movement.normalized() * speed velocity *= NetworkTime.physics_factor move_and_slide() Changing configuration RollbackSynchronizer has to do some setup work whenever the state or the input properties change. By default, this work is done upon instantiation. If you need to change state or input properties during runtime, make sure to call process_settings() , otherwise RollbackSynchronizer won't apply the changes. While changing configuration after instantiation is possible, it is not recommended. You may get away with it if the configuration change happens in a few ticks after instantiation. For longer periods, experiment at your own risk. Changing ownership The setup work above is also needed whenever the multiplayer authority changes of any of the nodes that have a state- or input property. Changing authority during gameplay is supported. Make sure to call process_authority() on all peers at the same time, to ensure they're on sync about ownership. This method is called automatically during instantiation and whenever process_settings() is called. When only multiplayer authority changes, call process_authority() . When the configured state- or input properties change ( i.e. different properties need to be synced ), call process_settings() .","title":"RollbackSynchronizer"},{"location":"netfox/nodes/rollback-synchronizer/#rollbacksynchronizer","text":"Manages state during the network rollback loop by hooking into NetworkRollback events. Simulates nodes as required during rollback.","title":"RollbackSynchronizer"},{"location":"netfox/nodes/rollback-synchronizer/#configuring-state-and-input","text":"To use RollbackSynchronizer , add it as a child to the target node, specify the root node, and configure which properties to manage: Root specifies the root node for resolving state and input properties. Best practice dictates to add RollbackSynchronizer under its target, so Root will most often be the RollbackSynchronizer 's parent node. State properties are recorded for each tick and restored during rollback. For state, the server is the ultimate authority. Make sure that nodes containing state properties are owned by the server. Input properties are gathered for each player and sent to the server to use for simulation. Make sure that nodes containing input properties are owned by their respective players. See Property paths on how to specify properties. enable_input_broadcast toggles whether input properties are broadcast to all peers, or only to the server. The default is true to support legacy behaviour. It is recommended to turn this off to lower bandwidth and lessen the attack surface for cheating. Note that it is not recommended to have both state and input properties on the same node. Since nodes with state belong to the server, and nodes with input belong to the player, it is difficult to separate ownership on the same node.","title":"Configuring state and input"},{"location":"netfox/nodes/rollback-synchronizer/#writing-rollback-aware-scripts","text":"During setup, RollbackSynchronizer finds all the rollback-aware nodes under the specified root . During rollback, it will call all the rollback-aware nodes to simulate new state. To learn about rollback-awareness, see NetworkRollback . In short, implement _rollback_tick in your scripts: extends CharacterBody3D @export var speed = 4.0 @export var input: PlayerInput func _rollback_tick(delta, tick, is_fresh): velocity = input.movement.normalized() * speed velocity *= NetworkTime.physics_factor move_and_slide()","title":"Writing rollback-aware scripts"},{"location":"netfox/nodes/rollback-synchronizer/#changing-configuration","text":"RollbackSynchronizer has to do some setup work whenever the state or the input properties change. By default, this work is done upon instantiation. If you need to change state or input properties during runtime, make sure to call process_settings() , otherwise RollbackSynchronizer won't apply the changes. While changing configuration after instantiation is possible, it is not recommended. You may get away with it if the configuration change happens in a few ticks after instantiation. For longer periods, experiment at your own risk.","title":"Changing configuration"},{"location":"netfox/nodes/rollback-synchronizer/#changing-ownership","text":"The setup work above is also needed whenever the multiplayer authority changes of any of the nodes that have a state- or input property. Changing authority during gameplay is supported. Make sure to call process_authority() on all peers at the same time, to ensure they're on sync about ownership. This method is called automatically during instantiation and whenever process_settings() is called. When only multiplayer authority changes, call process_authority() . When the configured state- or input properties change ( i.e. different properties need to be synced ), call process_settings() .","title":"Changing ownership"},{"location":"netfox/nodes/state-synchronizer/","text":"StateSynchronizer Synchronizes state from the node's authority to other peers. Similar to Godot's MultiplayerSynchronizer , but is tied to the network tick loop . Works well with TickInterpolator . One way to use this node is to synchronize logic that runs only on the server, for example NPC's in your games. The NPC's are controlled fully by the server, and their state is synchronized to the clients by the StateSynchronizer nodes. Configuring state To use StateSynchronizer , add it as a child to the target node, specify the root node, and configure which properties to synchronize: Root specifies the root node for resolving properties. Best practice dictates to add StateSynchronizer under its target, so Root will most often be the StateSynchronizer 's parent node. Properties are recorded for each tick on the node's authority ( usually the server ), and broadcast to other peers. These are analogous to RollbackSynchronizer 's state properties . See Property paths on how to specify properties. Changing configuration StateSynchronizer has to do some setup work whenever the state or the input properties change. By default, this work is done upon instantiation. If you need to change properties during runtime, make sure to call process_settings() , otherwise StateSynchronizer won't apply the changes. You can change the node's authority without calling process_settings() again. Make sure that the authority is changed the same way on all peers, to avoid discrepancies. When to use StateSynchronizer and MultiplayerSynchronizer Part of the design philosophy of netfox is to build on top of Godot's networking tools, instead of replacing them. Both MultiplayerSynchronizer and StateSynchronizer can be used to synchronize state from authority to the rest of the peers. MultiplayerSynchronizer uses its own timer, and is independent of netfox's network tick loop . It can also do delta updates, and manage visibility per peer. Since it is not tied to netfox's tick loop, it does not work with TickInterpolator . StateSynchronizer records all the properties specified and broadcasts them as-is to all peers. This does not include visiblity or delta updates. The broadcast happens on every network tick. This node is explicitly designed to work with TickInterpolator . You can use StateSynchronizer for properties that you want to be interpolated, like position, rotation, or any other visual properties. You can use MultiplayerSynchronizer for properties that either don't need interpolation ( e.g. a unit's HP ), or specifically need one of MultiplayerSynchronizer 's features.","title":"StateSynchronizer"},{"location":"netfox/nodes/state-synchronizer/#statesynchronizer","text":"Synchronizes state from the node's authority to other peers. Similar to Godot's MultiplayerSynchronizer , but is tied to the network tick loop . Works well with TickInterpolator . One way to use this node is to synchronize logic that runs only on the server, for example NPC's in your games. The NPC's are controlled fully by the server, and their state is synchronized to the clients by the StateSynchronizer nodes.","title":"StateSynchronizer"},{"location":"netfox/nodes/state-synchronizer/#configuring-state","text":"To use StateSynchronizer , add it as a child to the target node, specify the root node, and configure which properties to synchronize: Root specifies the root node for resolving properties. Best practice dictates to add StateSynchronizer under its target, so Root will most often be the StateSynchronizer 's parent node. Properties are recorded for each tick on the node's authority ( usually the server ), and broadcast to other peers. These are analogous to RollbackSynchronizer 's state properties . See Property paths on how to specify properties.","title":"Configuring state"},{"location":"netfox/nodes/state-synchronizer/#changing-configuration","text":"StateSynchronizer has to do some setup work whenever the state or the input properties change. By default, this work is done upon instantiation. If you need to change properties during runtime, make sure to call process_settings() , otherwise StateSynchronizer won't apply the changes. You can change the node's authority without calling process_settings() again. Make sure that the authority is changed the same way on all peers, to avoid discrepancies.","title":"Changing configuration"},{"location":"netfox/nodes/state-synchronizer/#when-to-use-statesynchronizer-and-multiplayersynchronizer","text":"Part of the design philosophy of netfox is to build on top of Godot's networking tools, instead of replacing them. Both MultiplayerSynchronizer and StateSynchronizer can be used to synchronize state from authority to the rest of the peers. MultiplayerSynchronizer uses its own timer, and is independent of netfox's network tick loop . It can also do delta updates, and manage visibility per peer. Since it is not tied to netfox's tick loop, it does not work with TickInterpolator . StateSynchronizer records all the properties specified and broadcasts them as-is to all peers. This does not include visiblity or delta updates. The broadcast happens on every network tick. This node is explicitly designed to work with TickInterpolator . You can use StateSynchronizer for properties that you want to be interpolated, like position, rotation, or any other visual properties. You can use MultiplayerSynchronizer for properties that either don't need interpolation ( e.g. a unit's HP ), or specifically need one of MultiplayerSynchronizer 's features.","title":"When to use StateSynchronizer and MultiplayerSynchronizer"},{"location":"netfox/nodes/tick-interpolator/","text":"TickInterpolator Interpolates between network ticks to smooth out motion. Uses Interpolators under the hood to support various data types. Configuring interpolation To use TickInterpolator , add it as a child to the target node, specify the root node, and configure which properties to interpolate: Root specifies the root node for resolving Properties . Best practice dictates to add TickInterpolator under its target, so Root will most often be the TickInterpolator 's parent node. Properties specify which properties to interpolate. See Property paths on how to specify these values. Record First State will make TickInterpolator take a snapshot when the Node is instantiated. This snapshot will be used for interpolation, instead of waiting for the next network tick. Useful for objects which start moving instantly upon entering the scene tree, like projectiles. Enable Recording toggles automatic state recording. When enabled, TickInterpolator will take a new snapshot after each network tick loop and interpolate towards that. Disabling this will require you to manually call push_state() whenever the properties are updated. Sudden changes When a node makes a sudden change, like teleporting from one place to another, interpolation may not be desired. Call teleport() in these cases to avoid interpolation and just jump to the current state. Interpolation will resume after the current state. Example: func _tick(tick, delta): # Respawn after a while if _tick == respawn_tick: # Jump to spawn point, without interpolation position = spawn_position $TickInterpolator.teleport() Changing configuration TickInterpolator has to do some setup work whenever the interpolated properties change, e.g. when a new property needs to be interpolated. By default, this work is done upon instantiation. If you need to change interpolated properties during runtime, make sure to call process_settings() , otherwise TickInterpolator won't apply the changes.","title":"TickInterpolator"},{"location":"netfox/nodes/tick-interpolator/#tickinterpolator","text":"Interpolates between network ticks to smooth out motion. Uses Interpolators under the hood to support various data types.","title":"TickInterpolator"},{"location":"netfox/nodes/tick-interpolator/#configuring-interpolation","text":"To use TickInterpolator , add it as a child to the target node, specify the root node, and configure which properties to interpolate: Root specifies the root node for resolving Properties . Best practice dictates to add TickInterpolator under its target, so Root will most often be the TickInterpolator 's parent node. Properties specify which properties to interpolate. See Property paths on how to specify these values. Record First State will make TickInterpolator take a snapshot when the Node is instantiated. This snapshot will be used for interpolation, instead of waiting for the next network tick. Useful for objects which start moving instantly upon entering the scene tree, like projectiles. Enable Recording toggles automatic state recording. When enabled, TickInterpolator will take a new snapshot after each network tick loop and interpolate towards that. Disabling this will require you to manually call push_state() whenever the properties are updated.","title":"Configuring interpolation"},{"location":"netfox/nodes/tick-interpolator/#sudden-changes","text":"When a node makes a sudden change, like teleporting from one place to another, interpolation may not be desired. Call teleport() in these cases to avoid interpolation and just jump to the current state. Interpolation will resume after the current state. Example: func _tick(tick, delta): # Respawn after a while if _tick == respawn_tick: # Jump to spawn point, without interpolation position = spawn_position $TickInterpolator.teleport()","title":"Sudden changes"},{"location":"netfox/nodes/tick-interpolator/#changing-configuration","text":"TickInterpolator has to do some setup work whenever the interpolated properties change, e.g. when a new property needs to be interpolated. By default, this work is done upon instantiation. If you need to change interpolated properties during runtime, make sure to call process_settings() , otherwise TickInterpolator won't apply the changes.","title":"Changing configuration"},{"location":"netfox/tutorials/responsive-player-movement/","text":"Responsive player movement To compensate for latency, netfox implements Client-side prediction and Server reconciliation . This documentation also refers to it as rollback. One use case is player movement - with CSP we don't need to wait for the server's response before the player's avatar can be updated. Gathering input For CSP, input is separated from player state. In practice, this means that there's a separate node with its own script that manages input. The job of this script is to manage properties related to input - for example, which direction the player wants to move: extends Node class_name PlayerInput var movement = Vector3.ZERO These input properties must be updated based on player input. Hook into the network tick loop 's before_tick_loop signal to update input properties: func _ready(): NetworkTime.before_tick_loop.connect(_gather) func _gather(): if not is_multiplayer_authority(): return movement = Vector3( Input.get_axis(\"move_west\", \"move_east\"), Input.get_action_strength(\"move_jump\"), Input.get_axis(\"move_north\", \"move_south\") ) It is important to only update input properties if we have authority over the node. Otherwise we would try to change some other player's input with our own actions. Using BaseNetInput The same can be accomplished with BaseNetInput , with slightly less code: extends BaseNetInput class_name PlayerInput var movement: Vector3 = Vector3.ZERO func _gather(): movement = Vector3( Input.get_axis(\"move_west\", \"move_east\"), Input.get_action_strength(\"move_jump\"), Input.get_axis(\"move_north\", \"move_south\") ) Applying movement The other part of the equation is state . Use the same approach as you would with your character controller, with the game logic being implemented in _rollback_tick instead of _process or _physics_process : extends CharacterBody3D @export var speed = 4.0 @export var input: PlayerInput func _rollback_tick(delta, tick, is_fresh): velocity = input.movement.normalized() * speed velocity *= NetworkTime.physics_factor move_and_slide() Note the usage of physics_factor - this is explained in the caveats . Configuring rollback Create a reusable player scene with the following layout: The root is a CharacterBody3D with the player controller script attached. The Input child manages player input and has the player input script attached. The RollbackSynchronizer node manages the rollback logic, making the player motion responsive while also keeping it server-authoritative . Configure the RollbackSynchronizer with the following input- and state properties: Ownership Make sure that all of the player nodes are owned by the server. The exception is the Input node, which must be owned by the player who the avatar belongs to. After setting ownerships, make sure to call process_settings on RollbackSynchronizer . This call is necessary after every ownership change. RollbackSynchronizer sorts properties based on ownership, but this sorting is only done in process_settings . For example: @onready var rollback_synchronizer = $RollbackSynchronizer var peer_id = 0 func _ready(): # Wait a frame so peer_id is set await get_tree().process_frame # Set owner set_multiplayer_authority(1) input.set_multiplayer_authority(peer_id) rollback_synchronizer.process_settings() Note that peer_id needs to be set from the outside during spawn. Smooth motion Currently, state is only updated on network ticks. If the tickrate is less than the FPS the game is running on, motion may get choppy. Add a TickInterpolator node and configure it with the same state properties as the RollbackSynchronizer : This will ensure smooth motion, regardless of FPS and tickrate.","title":"Responsive player movement"},{"location":"netfox/tutorials/responsive-player-movement/#responsive-player-movement","text":"To compensate for latency, netfox implements Client-side prediction and Server reconciliation . This documentation also refers to it as rollback. One use case is player movement - with CSP we don't need to wait for the server's response before the player's avatar can be updated.","title":"Responsive player movement"},{"location":"netfox/tutorials/responsive-player-movement/#gathering-input","text":"For CSP, input is separated from player state. In practice, this means that there's a separate node with its own script that manages input. The job of this script is to manage properties related to input - for example, which direction the player wants to move: extends Node class_name PlayerInput var movement = Vector3.ZERO These input properties must be updated based on player input. Hook into the network tick loop 's before_tick_loop signal to update input properties: func _ready(): NetworkTime.before_tick_loop.connect(_gather) func _gather(): if not is_multiplayer_authority(): return movement = Vector3( Input.get_axis(\"move_west\", \"move_east\"), Input.get_action_strength(\"move_jump\"), Input.get_axis(\"move_north\", \"move_south\") ) It is important to only update input properties if we have authority over the node. Otherwise we would try to change some other player's input with our own actions.","title":"Gathering input"},{"location":"netfox/tutorials/responsive-player-movement/#using-basenetinput","text":"The same can be accomplished with BaseNetInput , with slightly less code: extends BaseNetInput class_name PlayerInput var movement: Vector3 = Vector3.ZERO func _gather(): movement = Vector3( Input.get_axis(\"move_west\", \"move_east\"), Input.get_action_strength(\"move_jump\"), Input.get_axis(\"move_north\", \"move_south\") )","title":"Using BaseNetInput"},{"location":"netfox/tutorials/responsive-player-movement/#applying-movement","text":"The other part of the equation is state . Use the same approach as you would with your character controller, with the game logic being implemented in _rollback_tick instead of _process or _physics_process : extends CharacterBody3D @export var speed = 4.0 @export var input: PlayerInput func _rollback_tick(delta, tick, is_fresh): velocity = input.movement.normalized() * speed velocity *= NetworkTime.physics_factor move_and_slide() Note the usage of physics_factor - this is explained in the caveats .","title":"Applying movement"},{"location":"netfox/tutorials/responsive-player-movement/#configuring-rollback","text":"Create a reusable player scene with the following layout: The root is a CharacterBody3D with the player controller script attached. The Input child manages player input and has the player input script attached. The RollbackSynchronizer node manages the rollback logic, making the player motion responsive while also keeping it server-authoritative . Configure the RollbackSynchronizer with the following input- and state properties:","title":"Configuring rollback"},{"location":"netfox/tutorials/responsive-player-movement/#ownership","text":"Make sure that all of the player nodes are owned by the server. The exception is the Input node, which must be owned by the player who the avatar belongs to. After setting ownerships, make sure to call process_settings on RollbackSynchronizer . This call is necessary after every ownership change. RollbackSynchronizer sorts properties based on ownership, but this sorting is only done in process_settings . For example: @onready var rollback_synchronizer = $RollbackSynchronizer var peer_id = 0 func _ready(): # Wait a frame so peer_id is set await get_tree().process_frame # Set owner set_multiplayer_authority(1) input.set_multiplayer_authority(peer_id) rollback_synchronizer.process_settings() Note that peer_id needs to be set from the outside during spawn.","title":"Ownership"},{"location":"netfox/tutorials/responsive-player-movement/#smooth-motion","text":"Currently, state is only updated on network ticks. If the tickrate is less than the FPS the game is running on, motion may get choppy. Add a TickInterpolator node and configure it with the same state properties as the RollbackSynchronizer : This will ensure smooth motion, regardless of FPS and tickrate.","title":"Smooth motion"},{"location":"netfox/tutorials/rollback-caveats/","text":"Rollback caveats As with most things, rollback has some drawbacks along with its benefits. CharacterBody velocity Godot's move_and_slide() uses the velocity property, which is set in meters/second. The method assumes a delta time based on what kind of frame is being run. However, it is not aware of netfox 's network ticks, which means that movement speed will be off. To counteract this, multiply velocity with NetworkTime.physics_factor , which will adjust for the difference between Godot's assumed delta time and the delta time netfox is using. If you don't want to lose your original velocity ( e.g. because it accumulates acceleration over time ), divide by the same property after using any built-in method. For example: # Apply movement velocity *= NetworkTime.physics_factor move_and_slide() velocity /= NetworkTime.physics_factor CharacterBody on floor CharacterBodies only update their is_on_floor() state only after a move_and_slide() call. This means that during rollback, the position is updated, but the is_on_floor() state is not. As a work-around, do a zero-velocity move before checking if the node is on the floor: extends CharacterBody3D func _rollback_tick(delta, tick, is_fresh): # Add the gravity. _force_update_is_on_floor() if not is_on_floor(): velocity.y -= gravity * delta # ... func _force_update_is_on_floor(): var old_velocity = velocity velocity = Vector3.ZERO move_and_slide() velocity = old_velocity Physics updates Godot's physics system is updated only during _physics_process , while rollback updates the game state multiple times during a single frame. Unfortunately, Godot does not support manually updating or stepping the physics system, at least at the time of writing . This means that: Rollback and physics-based games don't work at the moment Collision detection can work, but with workarounds If there's a way to force an update for your given node type, it should work.","title":"Rollback caveats"},{"location":"netfox/tutorials/rollback-caveats/#rollback-caveats","text":"As with most things, rollback has some drawbacks along with its benefits.","title":"Rollback caveats"},{"location":"netfox/tutorials/rollback-caveats/#characterbody-velocity","text":"Godot's move_and_slide() uses the velocity property, which is set in meters/second. The method assumes a delta time based on what kind of frame is being run. However, it is not aware of netfox 's network ticks, which means that movement speed will be off. To counteract this, multiply velocity with NetworkTime.physics_factor , which will adjust for the difference between Godot's assumed delta time and the delta time netfox is using. If you don't want to lose your original velocity ( e.g. because it accumulates acceleration over time ), divide by the same property after using any built-in method. For example: # Apply movement velocity *= NetworkTime.physics_factor move_and_slide() velocity /= NetworkTime.physics_factor","title":"CharacterBody velocity"},{"location":"netfox/tutorials/rollback-caveats/#characterbody-on-floor","text":"CharacterBodies only update their is_on_floor() state only after a move_and_slide() call. This means that during rollback, the position is updated, but the is_on_floor() state is not. As a work-around, do a zero-velocity move before checking if the node is on the floor: extends CharacterBody3D func _rollback_tick(delta, tick, is_fresh): # Add the gravity. _force_update_is_on_floor() if not is_on_floor(): velocity.y -= gravity * delta # ... func _force_update_is_on_floor(): var old_velocity = velocity velocity = Vector3.ZERO move_and_slide() velocity = old_velocity","title":"CharacterBody on floor"},{"location":"netfox/tutorials/rollback-caveats/#physics-updates","text":"Godot's physics system is updated only during _physics_process , while rollback updates the game state multiple times during a single frame. Unfortunately, Godot does not support manually updating or stepping the physics system, at least at the time of writing . This means that: Rollback and physics-based games don't work at the moment Collision detection can work, but with workarounds If there's a way to force an update for your given node type, it should work.","title":"Physics updates"},{"location":"netfox.extras/guides/base-net-input/","text":"BaseNetInput Base class for Input nodes used with rollback. During rollback, multiple logical ticks are simulated in the span of a single network tick. Since these are just logical ticks, no actual input arrives during them from the input devices. The solution is to gather input before the tick loop, and use that input for any new ticks simulated during the rollback. Gathering input This class provides a virtual _gather method that you can override. Set the variables configured in RollbackSynchronizer in your own implementation: extends BaseNetInput var movement: Vector3 = Vector3.ZERO func _gather(): movement = Vector3( Input.get_axis(\"move_west\", \"move_east\"), 0, Input.get_axis(\"move_north\", \"move_south\") )","title":"BaseNetInput"},{"location":"netfox.extras/guides/base-net-input/#basenetinput","text":"Base class for Input nodes used with rollback. During rollback, multiple logical ticks are simulated in the span of a single network tick. Since these are just logical ticks, no actual input arrives during them from the input devices. The solution is to gather input before the tick loop, and use that input for any new ticks simulated during the rollback.","title":"BaseNetInput"},{"location":"netfox.extras/guides/base-net-input/#gathering-input","text":"This class provides a virtual _gather method that you can override. Set the variables configured in RollbackSynchronizer in your own implementation: extends BaseNetInput var movement: Vector3 = Vector3.ZERO func _gather(): movement = Vector3( Input.get_axis(\"move_west\", \"move_east\"), 0, Input.get_axis(\"move_north\", \"move_south\") )","title":"Gathering input"},{"location":"netfox.extras/guides/network-weapon/","text":"NetworkWeapon Class to simplify writing networked weapons. A weapon, in this context, is anything that can be fired and spawn objects ( projectiles ) upon being fired. Responsive projectiles Upon firing, sending a request to the server and waiting for the response with the projectile would introduce a delay. Doing a full-on state synchronization with MultiplayerSynchronizer or RollbackSynchronizer can be unfeasible with too many projectiles, and unnecessary, since most of the time, projectiles act and move the same way regardless of their surroundings. Instead, upon firing, a projectile is spawned instantly. At the same time, a request is sent to the server. If the server accepts the projectile, it will spawn it and broadcasts its starting state. Since the server's state is the source of truth, the projectile's local state will be updated with the difference. This is called reconciliation . If the client requests a projectile with an unlikely state, it will be rejected. This is to avoid players cheating, for example by requesting projectiles at a more advantageous position than they're at. If the server is too strict with what difference is considered acceptable and what not, legitimate players may get cases where they fire a projectile which disappears after a short time period. Implementing a weapon NetworkWeapon provides multiple functions to override. Make sure that all these methods work the same way on every player's game, otherwise players will experience glitches. _can_fire returns a bool, indicating whether the weapon can be fired. For example, this method can return false if the weapon was fired recently and is still on cooldown. Do not update state here. Use _after_fire instead. _can_peer_use indicates whether a given peer can fire the weapon. Due to the way RPCs are set up under the hood, any of the players can try to fire a weapon. Use this method to check if the player trying to fire has permission, e.g. a player is not trying to use someone else's weapon. _after_fire is called after the weapon is successfully fired. Can be used to update state ( e.g. last time the weapon was fired ) and play sound effects. _spawn creates the projectile. Make sure to return the created node. _get_data must return the projectile's starting state in a dictionary. This can contain any property that is relevant to the projectile and must be synchronized. For example, global_transform is important to ensure that the projectile starts from the right position. On the other hand, projectile speed does not need to be captured if it's the same for every projectile. _apply_data must apply the captured properties to a projectile. _is_reconcilable checks if the difference between two projectile states ( as captured by _get_data ) is close enough to be allowed. Can be used to reject cheating. _reconcile adjusts the projectile based on the difference between the local and server state. Specializations NetworkWeapon extends Node . This also means that anything extending NetworkWeapon is also a node, and thus can't have a position for example. Two specialized classes are provided - NetworkWeapon3D , and NetworkWeapon2D - extending Node3D and Node2D respectively. This way, weapons can have transforms and have a presence in the game world. They also take care of reconciliation, implementing _get_data , _apply_data , _is_reconcilable , and _reconcile . These can be overridden, but make sure to to call the base class with super(...) . Reconciliation is based on distance, and can be configured with the distance_threshold property. Under the hood, these specializations create a special NetworkWeapon node, that proxies all the method calls back to the specialization. This is a workaround to build multiple inheritance in a single inheritance language.","title":"NetworkWeapon"},{"location":"netfox.extras/guides/network-weapon/#networkweapon","text":"Class to simplify writing networked weapons. A weapon, in this context, is anything that can be fired and spawn objects ( projectiles ) upon being fired.","title":"NetworkWeapon"},{"location":"netfox.extras/guides/network-weapon/#responsive-projectiles","text":"Upon firing, sending a request to the server and waiting for the response with the projectile would introduce a delay. Doing a full-on state synchronization with MultiplayerSynchronizer or RollbackSynchronizer can be unfeasible with too many projectiles, and unnecessary, since most of the time, projectiles act and move the same way regardless of their surroundings. Instead, upon firing, a projectile is spawned instantly. At the same time, a request is sent to the server. If the server accepts the projectile, it will spawn it and broadcasts its starting state. Since the server's state is the source of truth, the projectile's local state will be updated with the difference. This is called reconciliation . If the client requests a projectile with an unlikely state, it will be rejected. This is to avoid players cheating, for example by requesting projectiles at a more advantageous position than they're at. If the server is too strict with what difference is considered acceptable and what not, legitimate players may get cases where they fire a projectile which disappears after a short time period.","title":"Responsive projectiles"},{"location":"netfox.extras/guides/network-weapon/#implementing-a-weapon","text":"NetworkWeapon provides multiple functions to override. Make sure that all these methods work the same way on every player's game, otherwise players will experience glitches. _can_fire returns a bool, indicating whether the weapon can be fired. For example, this method can return false if the weapon was fired recently and is still on cooldown. Do not update state here. Use _after_fire instead. _can_peer_use indicates whether a given peer can fire the weapon. Due to the way RPCs are set up under the hood, any of the players can try to fire a weapon. Use this method to check if the player trying to fire has permission, e.g. a player is not trying to use someone else's weapon. _after_fire is called after the weapon is successfully fired. Can be used to update state ( e.g. last time the weapon was fired ) and play sound effects. _spawn creates the projectile. Make sure to return the created node. _get_data must return the projectile's starting state in a dictionary. This can contain any property that is relevant to the projectile and must be synchronized. For example, global_transform is important to ensure that the projectile starts from the right position. On the other hand, projectile speed does not need to be captured if it's the same for every projectile. _apply_data must apply the captured properties to a projectile. _is_reconcilable checks if the difference between two projectile states ( as captured by _get_data ) is close enough to be allowed. Can be used to reject cheating. _reconcile adjusts the projectile based on the difference between the local and server state.","title":"Implementing a weapon"},{"location":"netfox.extras/guides/network-weapon/#specializations","text":"NetworkWeapon extends Node . This also means that anything extending NetworkWeapon is also a node, and thus can't have a position for example. Two specialized classes are provided - NetworkWeapon3D , and NetworkWeapon2D - extending Node3D and Node2D respectively. This way, weapons can have transforms and have a presence in the game world. They also take care of reconciliation, implementing _get_data , _apply_data , _is_reconcilable , and _reconcile . These can be overridden, but make sure to to call the base class with super(...) . Reconciliation is based on distance, and can be configured with the distance_threshold property. Under the hood, these specializations create a special NetworkWeapon node, that proxies all the method calls back to the specialization. This is a workaround to build multiple inheritance in a single inheritance language.","title":"Specializations"},{"location":"netfox.noray/guides/noray/","text":"Noray Singleton providing noray integration. noray is a backend application that orchestrates connection between players. To do this, players send a connection request to noray , and in turn noray sends the players' external addresses to eachother. It is then up to the players to conduct a handshake process. If the handshake fails, players can request a relay from noray . In these cases, noray will receive data from one player and forward it to the other, acting as a middle man. Identifiers noray identifies players with two different IDs: OpenID and PrivateID. OpenID is public, and can be shared with other players. This ID is used to identify hosts when connecting to games. PrivateID is only sent to the player it identifies and should never be shared. Acts similar to a password, and is used to authorize commands. Relays and NAT Punchthrough noray provides two methods of connecting players. NAT Punchthrough relies on the NAT table. Players must continuously send data to eachother until either two-way communication is established, or a timeout is reached. For certain router setups, NAT punchthrough does not work. See: NAT Punch-through for Multiplayer Games For relays , noray allocates a specific port to a given player. When noray receives data on this port, it will forward it as-is to the player. As long as noray is accessible over the internet, relays should work reliably no matter the router setup. Registering with noray To start using noray , connect to a noray server, request IDs by registering, and then register the remote address: var host = \"some.noray.host\" var port = 8890 var err = OK # Connect to noray err = await Noray.connect_to_host(host, port) if err != OK: return err # Failed to connect # Register host Noray.register_host() await Noray.on_pid # Register remote address # This is where noray will direct traffic err = await Noray.register_remote() if err != OK: return err # Failed to register By calling Noray.register_host() , a request is sent to noray . Once a response is received, both the on_pid and on_oid signals are fired, for receiving the PrivateID and OpenID respectively. The remote address must be registered so that noray knows where to direct other players wanting to connect. This process also sets Noray.local_port , which is where traffic can be received through noray . Starting a host To host a game, start listening on noray 's local port: var peer = ENetMultiplayerPeer.new() var err = peer.create_server(Noray.local_port) if err != OK: return false # Failed to listen on port The rest is handled by noray . Starting a client To connect to a game, send a request to noray with the host's OpenID. var oid = \"abcd1234\" # Connect using NAT punchthrough Noray.connect_nat(oid) # Or connect using relay Noray.connect_relay(oid) Once the request is sent, noray will send a message to both the client and the host players to connect to each other. The actual connection is done by handling signals. Note that noray provides no functionality to share OpenIDs. For development, you can display the OpenID in a textbox, letting players copy it and share over their preferred messaging app. Handling signals When a connect message is received, the appropriate signal is fired. on_connect_nat is fired to connect with NAT punchthrough. on_connect_relay is fired to connect to a relay. In both cases, a public address is passed to the signal handler, in the form of an address string and a port. Handlers must conduct a handshake ( e.g. with PacketHandshake ) and connect if successful. Client example: func _ready(): Noray.on_connect_nat.connect(_handle_connect) Noray.on_connect_relay.connect(_handle_connect) func _handle_connect(address: String, port: int) -> Error: # Do a handshake var udp = PacketPeerUDP.new() udp.bind(Noray.local_port) udp.set_dest_address(address, port) var err = await PacketHandshake.over_packet_peer(udp) udp.close() if err != OK: return err # Connect to host var peer = ENetMultiplayerPeer.new() err = peer.create_client(address, port, 0, 0, 0, Noray.local_port) if err != OK: return err return OK Note: Make sure to always specifiy the local port for the client - this is the only port noray recognizes, and failing to specify it will result in broken connectivity. Host example: func _ready(): Noray.on_connect_nat.connect(_handle_connect) Noray.on_connect_relay.connect(_handle_connect) func _handle_connect(address: String, port: int) -> Error: var peer = get_tree().get_multiplayer().multiplayer_peer as ENetMultiplayerPeer var err = await PacketHandshake.over_enet(peer.host, address, port) if err != OK: return err return OK Note: The host handshake is a bit different, as it can't receive manual packets, only send them. So it assumes that the target is always responsive, and just blasts them with a bunch of packets. If the target is indeed responsive, it can connect. If not, nothing happens, as expected.","title":"Noray"},{"location":"netfox.noray/guides/noray/#noray","text":"Singleton providing noray integration. noray is a backend application that orchestrates connection between players. To do this, players send a connection request to noray , and in turn noray sends the players' external addresses to eachother. It is then up to the players to conduct a handshake process. If the handshake fails, players can request a relay from noray . In these cases, noray will receive data from one player and forward it to the other, acting as a middle man.","title":"Noray"},{"location":"netfox.noray/guides/noray/#identifiers","text":"noray identifies players with two different IDs: OpenID and PrivateID. OpenID is public, and can be shared with other players. This ID is used to identify hosts when connecting to games. PrivateID is only sent to the player it identifies and should never be shared. Acts similar to a password, and is used to authorize commands.","title":"Identifiers"},{"location":"netfox.noray/guides/noray/#relays-and-nat-punchthrough","text":"noray provides two methods of connecting players. NAT Punchthrough relies on the NAT table. Players must continuously send data to eachother until either two-way communication is established, or a timeout is reached. For certain router setups, NAT punchthrough does not work. See: NAT Punch-through for Multiplayer Games For relays , noray allocates a specific port to a given player. When noray receives data on this port, it will forward it as-is to the player. As long as noray is accessible over the internet, relays should work reliably no matter the router setup.","title":"Relays and NAT Punchthrough"},{"location":"netfox.noray/guides/noray/#registering-with-noray","text":"To start using noray , connect to a noray server, request IDs by registering, and then register the remote address: var host = \"some.noray.host\" var port = 8890 var err = OK # Connect to noray err = await Noray.connect_to_host(host, port) if err != OK: return err # Failed to connect # Register host Noray.register_host() await Noray.on_pid # Register remote address # This is where noray will direct traffic err = await Noray.register_remote() if err != OK: return err # Failed to register By calling Noray.register_host() , a request is sent to noray . Once a response is received, both the on_pid and on_oid signals are fired, for receiving the PrivateID and OpenID respectively. The remote address must be registered so that noray knows where to direct other players wanting to connect. This process also sets Noray.local_port , which is where traffic can be received through noray .","title":"Registering with noray"},{"location":"netfox.noray/guides/noray/#starting-a-host","text":"To host a game, start listening on noray 's local port: var peer = ENetMultiplayerPeer.new() var err = peer.create_server(Noray.local_port) if err != OK: return false # Failed to listen on port The rest is handled by noray .","title":"Starting a host"},{"location":"netfox.noray/guides/noray/#starting-a-client","text":"To connect to a game, send a request to noray with the host's OpenID. var oid = \"abcd1234\" # Connect using NAT punchthrough Noray.connect_nat(oid) # Or connect using relay Noray.connect_relay(oid) Once the request is sent, noray will send a message to both the client and the host players to connect to each other. The actual connection is done by handling signals. Note that noray provides no functionality to share OpenIDs. For development, you can display the OpenID in a textbox, letting players copy it and share over their preferred messaging app.","title":"Starting a client"},{"location":"netfox.noray/guides/noray/#handling-signals","text":"When a connect message is received, the appropriate signal is fired. on_connect_nat is fired to connect with NAT punchthrough. on_connect_relay is fired to connect to a relay. In both cases, a public address is passed to the signal handler, in the form of an address string and a port. Handlers must conduct a handshake ( e.g. with PacketHandshake ) and connect if successful. Client example: func _ready(): Noray.on_connect_nat.connect(_handle_connect) Noray.on_connect_relay.connect(_handle_connect) func _handle_connect(address: String, port: int) -> Error: # Do a handshake var udp = PacketPeerUDP.new() udp.bind(Noray.local_port) udp.set_dest_address(address, port) var err = await PacketHandshake.over_packet_peer(udp) udp.close() if err != OK: return err # Connect to host var peer = ENetMultiplayerPeer.new() err = peer.create_client(address, port, 0, 0, 0, Noray.local_port) if err != OK: return err return OK Note: Make sure to always specifiy the local port for the client - this is the only port noray recognizes, and failing to specify it will result in broken connectivity. Host example: func _ready(): Noray.on_connect_nat.connect(_handle_connect) Noray.on_connect_relay.connect(_handle_connect) func _handle_connect(address: String, port: int) -> Error: var peer = get_tree().get_multiplayer().multiplayer_peer as ENetMultiplayerPeer var err = await PacketHandshake.over_enet(peer.host, address, port) if err != OK: return err return OK Note: The host handshake is a bit different, as it can't receive manual packets, only send them. So it assumes that the target is always responsive, and just blasts them with a bunch of packets. If the target is indeed responsive, it can connect. If not, nothing happens, as expected.","title":"Handling signals"},{"location":"netfox.noray/guides/packet-handshake/","text":"PacketHandshake Singleton implementing handshake over UDP. The point of the handshake itself is to confirm two-way connection between two parties - i.e. both parties can receive message from the other and receive acknowledgement from the other that their messages have arrived. This is an important step before establishing connection for actual game play, as this lets both the client's and server's routers ( if any ) know that traffic is expected and should be let through. NAT punchthrough Most players are behind a router. Routers are directly connected to the internet, and protect machines behind them from unwanted traffic. When routers receive packets from an unknown source, those packets are rejected and don't reach the player's device. When data was sent to that address first, routers see traffic as a reply and allow incoming data. To take an example, if a random PC starts sending traffic your way, the router will reject it. If you send data to the host behind godotengine.org, your router will allow incoming traffic from it. Otherwise, you wouldn't be able to open the website in your browser, as the incoming HTTP response would be rejected. This can be used to our advantage. If both players start sending traffic towards eachother, eventually the routers will assume it's a response to some request and allow the traffic. This is a very simplified description of how routers work. NAT punchthrough does not always work. For further reading, see Network address translation . Handshake process To confirm two-way connectivity, a string is sent back and forth, encoding the player's knowledge about the connection: The Read flag is set once we have received data from the other player. The Write flag is set once we send data to the other player. Since data is always sent, this flag is always set. The Duplex flag is set when we have received data from the other player knowing that they have also received data from us. This means that data flows both ways. The handshake process is successful when both players have the Duplex flag set and both players know that the other player has the Duplex flag set. Each flag is encoded as its specific character or a hyphen. The encoded string is prepended with a dollar sign. For example: $rw- means that we have sent and received data from the other player $rwx means that the read , write , and duplex flags are all set Here's the handshake process illustrated: Handshake over PacketPeer To run the handshake over raw UDP, call PacketHandshake.over_packet_peer . The specified PacketPeer will be used to send data until two-way connectivity is confirmed or the timeout is reached. Between every packet sent, it takes a short pause. Note that the PacketPeer must already be configured with a target address. Handshake over ENetConnection If the game is already running, the handshake must be done over the already active connection. For this case, use PacketHandshake.over_enet . This connection can't be used to receive custom packets, only to send them. So the target address will be spammed with traffic confirming two-way connectivity until timeout. Handshake will always be considered successful. If the connectivity exists, players will simply connect. Otherwise, connectivity will fail as expected, regardless of the handshake results.","title":"PacketHandshake"},{"location":"netfox.noray/guides/packet-handshake/#packethandshake","text":"Singleton implementing handshake over UDP. The point of the handshake itself is to confirm two-way connection between two parties - i.e. both parties can receive message from the other and receive acknowledgement from the other that their messages have arrived. This is an important step before establishing connection for actual game play, as this lets both the client's and server's routers ( if any ) know that traffic is expected and should be let through.","title":"PacketHandshake"},{"location":"netfox.noray/guides/packet-handshake/#nat-punchthrough","text":"Most players are behind a router. Routers are directly connected to the internet, and protect machines behind them from unwanted traffic. When routers receive packets from an unknown source, those packets are rejected and don't reach the player's device. When data was sent to that address first, routers see traffic as a reply and allow incoming data. To take an example, if a random PC starts sending traffic your way, the router will reject it. If you send data to the host behind godotengine.org, your router will allow incoming traffic from it. Otherwise, you wouldn't be able to open the website in your browser, as the incoming HTTP response would be rejected. This can be used to our advantage. If both players start sending traffic towards eachother, eventually the routers will assume it's a response to some request and allow the traffic. This is a very simplified description of how routers work. NAT punchthrough does not always work. For further reading, see Network address translation .","title":"NAT punchthrough"},{"location":"netfox.noray/guides/packet-handshake/#handshake-process","text":"To confirm two-way connectivity, a string is sent back and forth, encoding the player's knowledge about the connection: The Read flag is set once we have received data from the other player. The Write flag is set once we send data to the other player. Since data is always sent, this flag is always set. The Duplex flag is set when we have received data from the other player knowing that they have also received data from us. This means that data flows both ways. The handshake process is successful when both players have the Duplex flag set and both players know that the other player has the Duplex flag set. Each flag is encoded as its specific character or a hyphen. The encoded string is prepended with a dollar sign. For example: $rw- means that we have sent and received data from the other player $rwx means that the read , write , and duplex flags are all set Here's the handshake process illustrated:","title":"Handshake process"},{"location":"netfox.noray/guides/packet-handshake/#handshake-over-packetpeer","text":"To run the handshake over raw UDP, call PacketHandshake.over_packet_peer . The specified PacketPeer will be used to send data until two-way connectivity is confirmed or the timeout is reached. Between every packet sent, it takes a short pause. Note that the PacketPeer must already be configured with a target address.","title":"Handshake over PacketPeer"},{"location":"netfox.noray/guides/packet-handshake/#handshake-over-enetconnection","text":"If the game is already running, the handshake must be done over the already active connection. For this case, use PacketHandshake.over_enet . This connection can't be used to receive custom packets, only to send them. So the target address will be spammed with traffic confirming two-way connectivity until timeout. Handshake will always be considered successful. If the connectivity exists, players will simply connect. Otherwise, connectivity will fail as expected, regardless of the handshake results.","title":"Handshake over ENetConnection"}]}